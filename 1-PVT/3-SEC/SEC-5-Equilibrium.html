
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Определение равновесного состояния системы &#8212; Основы моделирования пластовых систем</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=ea443c07" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '1-PVT/3-SEC/SEC-5-Equilibrium';</script>
    <script src="../../_static/custom.js?v=4c678b35"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Определение насыщенного состояния системы" href="SEC-6-Saturation.html" />
    <link rel="prev" title="Уравнение Речфорда-Райса для многофазных систем" href="SEC-4-RR-NP.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../Introduction.html">
  
  
  
  
  
  
    <p class="title logo__title">Основы моделирования пластовых систем</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../Introduction.html">
                    Основы моделирования пластовых систем
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Основы вычислительной математики</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../0-Math/Math-Introduction.html">Введение</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../0-Math/0-LAB/LAB-0-Introduction.html">Основы линейной алгебры</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-1-Vectors.html">Вектор. Координаты вектора</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-2-VectorOperations.html">Операции с векторами</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-3-RotationAngles.html">Направляющие косинусы</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-4-Matrices.html">Матрицы</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-5-Determinant-InverseMatrix.html">Определитель матрицы. Обратная матрица</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-6-Eigenvalues-Eigenvectors.html">Собственные векторы и значения матриц</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-7-LinearTransformations.html">Линейные преобразования</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-8-MatrixDefiniteness.html">Определенность матриц</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-9-Decomposition.html">Разложение матриц</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-10-LinearSystems.html">Решение систем линейных уравнений</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-11-ConditionNumber.html">Число обусловленности</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../0-Math/0-LAB/LAB-12-Preconditioner.html">Предобуславливание</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../../0-Math/1-OM/OM-0-Introduction.html">Методы оптимизации функций</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">PVT-моделирование</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../PVT-Introduction.html">Введение</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../1-TD/TD-0-Introduction.html">Основы термодинамики</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-1-Basics.html">Введение в термодинамику</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-2-ThermalEquilibrium.html">Термическое равновесие. Температура. Нулевое начало термодинамики</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-3-Heat-Work.html">Количество теплоты и работа. Первое начало термодинамики</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-4-HeatCapacity.html">Теплоемкость</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-5-Enthalpy.html">Энтальпия</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-6-Entropy.html">Энтропия. Второе и третье начала термодинамики</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-7-ChemicalPotential.html">Химический потенциал</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-8-Helmholtz-Gibbs.html">Энергия Гельмгольца. Энергия Гиббса</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-9-Observables.html">Интенсивные и экстенсивные параметры</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-10-MixtureGibbsEnergy.html">Энергия Гиббса многокомпонентной системы</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-11-GibbsPhaseRule.html">Правило фаз Гиббса</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-12-GibbsDuhemEquation.html">Уравнение Гиббса-Дюгема</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-13-MaxwellRelations.html">Соотношения Максвелла</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-14-PhaseEquilibrium.html">Свободная энергия и фазовое равновесие</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1-TD/TD-15-Fugacity.html">Летучесть</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../2-EOS/EOS-0-Introduction.html">Уравнения состояния</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../2-EOS/EOS-1-VanDerWaals.html">Уравнение состояния Ван-дер-Ваальса</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2-EOS/EOS-2-SRK-PR.html">Уравнения состояния Суаве-Редлиха-Квонга и Пенга-Робинсона</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2-EOS/EOS-3-CPA.html">Кубическое уравнение состояние с учетом ассоциации молекул</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2-EOS/EOS-Appendix-A-PD.html">Частные производные летучести компонентов</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2-EOS/EOS-Appendix-B-BIP.html">Универсальный расчет коэффициентов попарного взаимодействия</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2-EOS/EOS-Appendix-C-HV.html">Правило смешивания Хьюрона-Видаля</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="SEC-0-Introduction.html">Стабильность. Равновесие. Критическое состояние</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="SEC-1-Stability.html">Определение стабильности фазового состояния системы</a></li>
<li class="toctree-l2"><a class="reference internal" href="SEC-2-RR.html">Уравнение Речфорда-Райса</a></li>
<li class="toctree-l2"><a class="reference internal" href="SEC-3-RR-2P.html">Уравнение Речфорда-Райса для двухфазных систем</a></li>
<li class="toctree-l2"><a class="reference internal" href="SEC-4-RR-NP.html">Уравнение Речфорда-Райса для многофазных систем</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Определение равновесного состояния системы</a></li>
<li class="toctree-l2"><a class="reference internal" href="SEC-6-Saturation.html">Определение насыщенного состояния системы</a></li>
<li class="toctree-l2"><a class="reference internal" href="SEC-7-Criticality.html">Определение критического состояния системы</a></li>
</ul>
</details></li>
<li class="toctree-l1"><a class="reference internal" href="../4-LAB/LAB-0-Introduction.html">Моделирование лабораторных исследований</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5-ETC/ETC-0-Introduction.html">Применение PVT-моделирования для решения практических задач проектирования месторождений углеводородов</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/1-PVT/3-SEC/SEC-5-Equilibrium.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Определение равновесного состояния системы</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pt">PT-термодинамика</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vt">VT-термодинамика</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="pvt-esc-equilibrium">
<span id="id1"></span><h1>Определение равновесного состояния системы<a class="headerlink" href="#pvt-esc-equilibrium" title="Link to this heading">#</a></h1>
<p>В предыдущих разделах были представлены особенности проверки <a class="reference internal" href="SEC-1-Stability.html"><span class="std std-doc">стабильности фазового состояния системы</span></a>, а также получено <a class="reference internal" href="SEC-2-RR.html"><span class="std std-doc">уравнение Речфорда-Райса</span></a> и рассмотрены численные методы его решения для <a class="reference internal" href="SEC-3-RR-2P.html"><span class="std std-doc">двухфазной</span></a> и <a class="reference internal" href="SEC-4-RR-NP.html"><span class="std std-doc">многофазной</span></a> систем. Данный раздел посвящен расчету равновесного фазового состояния, проводимому в том случае, если по результатам анализа стабильности текущее фазовое состояние оказалось нестабильным. Как и в случае анализа стабильности, расчет равновесного состояния также имеет различные формулировки (<a class="reference internal" href="#pvt-esc-equilibrium-pt">PT-термодинамика</a>, <a class="reference internal" href="#pvt-esc-equilibrium-vt">VT-термодинамика</a>).</p>
<section id="pt">
<span id="pvt-esc-equilibrium-pt"></span><h2>PT-термодинамика<a class="headerlink" href="#pt" title="Link to this heading">#</a></h2>
<p>Задача поиска равновесного состояния многокомпонентной (<span class="math notranslate nohighlight">\(N_c\)</span> – количество компонентов) многофазной (<span class="math notranslate nohighlight">\(N_p\)</span> – количество фаз) системы для фиксированных давления <span class="math notranslate nohighlight">\(P\)</span>, температуры <span class="math notranslate nohighlight">\(T\)</span>, количеств вещества компонентов в системе <span class="math notranslate nohighlight">\(n_i, \, i = 1 \, \ldots \, N_c,\)</span> достаточно хорошо изучена и проработана. <a class="reference internal" href="../1-TD/TD-14-PhaseEquilibrium.html"><span class="std std-doc">Ранее</span></a> было показано, что равновесное состояние характеризуется минимумом энергии Гиббса. При этом необходимым условием равновесного состояния является равенство химических потенциалов (или летучестей) соответствующих компонентов в фазах. Это условие определяет положение стационарных точек функции энергии Гиббса, <a class="reference internal" href="SEC-1-Stability.html"><span class="std std-doc">называемых</span></a> стационарными состояниями системы.</p>
<p>В результате решения задачи поиска равновесного состояния системы требуется определить количества вещества компонентов в фазах, всего <span class="math notranslate nohighlight">\(N_c \times \left( N_p - 1 \right)\)</span> неизвестных с учетом ограничения <span class="math notranslate nohighlight">\(\sum_{j=1}^{N_p} n_{ji} = n_i, \, i = 1 \, \ldots \, N_c,\)</span> соответствующих положению минимума функции энергии Гиббса. Существует два основных направления решения данной задачи. Первое направление включает широкую группу подходов, основанных на <em><strong>методе последовательных подстановок</strong></em> <em>(successive (direct) substitution method)</em>. Данный метод, по сути, эквивалентен <a class="reference external" href="https://en.wikipedia.org/wiki/Gradient_descent">методу градиентного спуска</a> с длиной шага, равной единице, с точки зрения минимизации энергии Гиббса. Преимуществом данного метода является его относительная простота, поскольку нет необходимости в расчете многомерных матриц и вторых частных производных функции энергии Гиббса. Недостатком данного метода является необходимость сравнительно большого количества итераций для нахождения решения, при этом данный метод может сходиться к стационарным точкам функции. Метод последовательных подстановок подробно представлен в работах [<a class="reference external" href="https://doi.org/10.1016/0378-3812(82)85002-4">Michelsen, 1982b</a>; <a class="reference external" href="https://doi.org/10.1016/0378-3812(83)80115-0">Heidemann, 1983</a>; <a class="reference external" href="https://doi.org/10.1002/cjce.5450610414">Mehra et al, 1983</a>]. Другим направлением решения задачи поиска равновесного состояния является совокупность <a class="reference external" href="https://en.wikipedia.org/wiki/Global_optimization">методов глобальной оптимизации</a> функции энергии Гиббса, частично представленная в работах [<a class="reference external" href="https://doi.org/10.1016/S0098-1354(02)00144-8">Nichita et al, 2002</a>; <a class="reference external" href="https://doi.org/10.2118/04-05-TN2">Nichita et al, 2004</a>, <a class="reference external" href="https://doi.org/10.1016/j.fluid.2013.08.039">Petitfrere and Nichita, 2014</a>]. В рамках данного курса подробно остановимся на методах определения равновесного состояния, относящихся к первому направлению.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="note admonition">
<p class="admonition-title">Дополнительно</p>
<p>При использовании двойного индексирования здесь и далее первый индекс будет обозначать фазу, второй – компонент. То есть под <span class="math notranslate nohighlight">\(y_{ji}\)</span> следует понимать мольную долю <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(j\)</span>-й фазе, а под, например, <span class="math notranslate nohighlight">\(f_{N_pk}\)</span> – летучесть <span class="math notranslate nohighlight">\(k\)</span>-го компонента в <span class="math notranslate nohighlight">\(N_p\)</span>-й фазе. При использовании одинарного индексирования будет явно указано отношение данного элемента к вектору, характеризующему свойства фаз или компонентов.</p>
</div>
</aside>
<p>Отношение мольной доли <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(j\)</span>-й фазе, где <span class="math notranslate nohighlight">\(j = 1 \, \ldots \, N_p-1\)</span>, к мольной доли этого же компонента в референсной фазе (поскольку референсной фазой может быть любая, то здесь и далее под референсной фазой понимается фаза с индексом <span class="math notranslate nohighlight">\(N_p\)</span>) называется <em>константой фазового равновесия</em>:</p>
<div class="math notranslate nohighlight">
\[ K_{ji} = \frac{y_{ji}}{y_{N_pi}}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c. \]</div>
<p>Данный параметр также использовался при выводе <a class="reference internal" href="SEC-2-RR.html"><span class="std std-doc">уравнения Речфорда-Райса</span></a>.</p>
<p>Ключевой особенностью метода последовательных подстановок является итеративное обновление констант фазового равновесия в процессе поиска равновесного состояния, осуществляемое с использованием следующего выражения для <span class="math notranslate nohighlight">\(\left( k+1 \right)\)</span>-й итерации:</p>
<div class="math notranslate nohighlight">
\[ K_{ji}^{k+1} = K_{ji}^{k} \frac{f_{N_pi}}{f_{ji}}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c. \]</div>
<p>где <span class="math notranslate nohighlight">\(K_{ji}^{k+1}\)</span> – константа фазового равновесия <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(j\)</span>-й фазе на <span class="math notranslate nohighlight">\(\left( k+1 \right)\)</span>-й итерации, <span class="math notranslate nohighlight">\(K_{ji}^{k}\)</span> – константа фазового равновесия <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(j\)</span>-й фазе на <span class="math notranslate nohighlight">\(k\)</span>-й итерации, <span class="math notranslate nohighlight">\(f_{ji}\)</span> – летучесть <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(j\)</span>-й фазе, <span class="math notranslate nohighlight">\(f_{N_pi}\)</span> – летучесть <span class="math notranslate nohighlight">\(i\)</span>-го компонента в референсной фазе с индексом <span class="math notranslate nohighlight">\(N_p\)</span>.</p>
<p>Преобразуем данное выражение к следующему виду:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align}
\ln K_{ji}^{k+1} &amp;= \ln K_{ji}^{k} + \ln f_{N_pi} - \ln f_{ji}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c, \\
\Delta \ln K_{ji}^{k} &amp;= \ln f_{ji} - \ln f_{N_pi}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c, \\
\Delta \ln K_{ji}^{k} &amp;= \ln K_{ji}^{k} + \ln \varphi_{ji} - \ln \varphi_{N_pi}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c.
\end{align} \end{split}\]</div>
<p>Тогда итеративное обновление констант фазового равновесия в методе последовательных подстановок записывается в следующем виде:</p>
<div class="math notranslate nohighlight">
\[ \ln K_{ji}^{k+1} = \ln K_{ji}^{k} - \Delta \ln K_{ji}^{k}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c. \]</div>
<p>В свою очередь, метод градиентного спуска для минимизации функции энергии Гиббса с выбранными в качестве основных переменных логарифмами констант фазового равновесия:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align}
\ln K_{ji}^{k+1}
&amp;= \ln K_{ji}^{k} - \lambda \left( \frac{\partial \bar{G}}{\partial \ln K_{ji}} \right)_{P, \, T, \, K_{ml} \neq K_{ji}} \\
&amp;= \ln K_{ji}^{k} - \lambda \sum_{l=1}^{N_c} \sum_{m=1}^{N_p-1} \left( \frac{\partial \bar{G}}{\partial n_{ml}} \right)_{P, \, T, \, n_{ji} \neq n_{ml}} \left( \frac{\partial n_{ml}}{\partial \ln K_{ji}} \right)_{P, \, T, \, K_{ml} \neq K_{ji}} \\
&amp;= \ln K_{ji}^{k} - \lambda \sum_{l=1}^{N_c} \sum_{m=1}^{N_p-1} \left( \ln f_{ml} - \ln f_{N_pl} \right) U_{lmij}^{-1}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c.
\end{align} \end{split}\]</div>
<p>В представленном выражении параметр <span class="math notranslate nohighlight">\(\lambda\)</span> характеризует длину шага, а <span class="math notranslate nohighlight">\(\bar{G} = G / \left(RT\right)\)</span> – приведенная энергия Гиббса системы. При преобразовании данного выражения учитывалось <a class="reference external" href="https://en.wikipedia.org/wiki/Chain_rule#General_rule:_Vector-valued_functions_with_multiple_inputs">правило дифференцирования сложной функции от нескольких переменных</a>. Если принять</p>
<div class="math notranslate nohighlight">
\[ \lambda = 1, \]</div>
<div class="math notranslate nohighlight">
\[\begin{split} U_{lmij}^{-1} = \delta_{lmij} = \begin{cases} 1, \; l = i, \; m = j, \; i = 1 \, \ldots \, N_c, \; j = 1 \, \ldots \, N_p - 1, \\ 0, \; \mathrm{otherwise}, \end{cases} \end{split}\]</div>
<p>тогда метод последовательных подстановок будет эквивалентен методу градиентного спуска для минимизации функции энергии Гиббса. Таким образом, метод последовательных подстановок является своеобразным упрощением метода градиентного спуска для минимизации функции энергии Гиббса.</p>
<!-- TODO: добавить анализ матрицы U_{lmij}. См. 10.1002/cjce.5450610414, 10.1002/aic.690330606, 10.1016/j.fluid.2014.11.017 -->
<p>Рассмотрим алгоритм метода последовательных подстановок.</p>
<div class="algorithm admonition">
<p class="admonition-title">Алгоритм. Метод последовательных подстановок для определения равновесного состояния</p>
<p><strong>Дано:</strong> Вектор компонентного состава исследуемой системы <span class="math notranslate nohighlight">\(\mathbf{z} \in {\rm I\!R}^{N_c}\)</span>; термобарические условия <span class="math notranslate nohighlight">\(P\)</span> и <span class="math notranslate nohighlight">\(T\)</span>; количество вещества в системе <span class="math notranslate nohighlight">\(n=1 \, моль\)</span>; необходимые свойства компонентов для нахождения коэффициентов летучести компонентов с использованием уравнения состояния; количество фаз в системе <span class="math notranslate nohighlight">\(N_p\)</span>; набор (тензор) начальных приближений констант фазового равновесия <span class="math notranslate nohighlight">\(\mathbf{K}_0 \in {\rm I\!R}^{N \times \left( N_p - 1 \right) \times N_c}\)</span>; максимальное число итераций <span class="math notranslate nohighlight">\(N_{iter}\)</span>; точность <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<p><strong>Определить:</strong> Компонентные составы фаз <span class="math notranslate nohighlight">\(\mathbf{Y} \in {\rm I\!R}^{ \left( N_p - 1 \right) \times N_c}\)</span> и мольные доли фаз <span class="math notranslate nohighlight">\(\mathbf{F} \in {\rm I\!R}^{N_p-1}\)</span> в системе, соответствующие равновесному состоянию.</p>
<p><strong>Псевдокод:</strong><br />
<strong>def</strong> <span class="math notranslate nohighlight">\(\phi \left( \mathbf{Y} \in {\rm I\!R}^{\left( N_p - 1 \right) \times N_c}, \, \ldots \right) \rightarrow \mathbf{\Phi} \in {\rm I\!R}^{\left( N_p - 1 \right) \times N_c}\)</span> <span class="comment"># Функция для расчета матрицы коэф-тов летучести</span><br />
<strong>def</strong> <span class="math notranslate nohighlight">\(R \left( \mathbf{K} \in {\rm I\!R}^{\left( N_p - 1 \right) \times N_c}, \, \mathbf{z} \right) \rightarrow \mathbf{F} \in {\rm I\!R}^{N_p-1}\)</span> <span class="comment"># Функция для решения уравнения Речфорда-Райса</span><br />
<strong>for</strong> <span class="math notranslate nohighlight">\(i := 1\)</span> <strong>to</strong> <span class="math notranslate nohighlight">\(N\)</span> <strong>do</strong> <span class="comment"># Цикл перебора начальных приближений</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{K} := \mathbf{K}_0 \left[ i,:,: \right]\)</span> <span class="comment"># Матрица начальных приближений констант фазового равновесия</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{F} := R \left( \mathbf{K}, \, \mathbf{z} \right)\)</span> <span class="comment"># Вектор мольных долей фаз для начального приближения</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{x} := \mathbf{z} \, / \left( \mathbf{F}^\top \left(\mathbf{K} - 1 \right) + 1 \right)\)</span> <span class="comment"># Компонентный состав референсной фазы</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{Y} := \mathbf{K} \cdot \mathbf{x}\)</span> <span class="comment"># Матрица компонентных составов нереференсных фаз</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{\Phi} := \phi \left( \mathbf{Y} \right)\)</span> <span class="comment"># Матрица коэффициентов летучести компонентов в нереференсных фазах</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{\varphi} := \phi \left( \mathbf{x} \right)\)</span> <span class="comment"># Вектор коэффициентов летучести компонентов в референсной фазе</span><br />
 <span class="math notranslate nohighlight">\(\mathbf{g} := \ln \mathbf{K} + \ln \mathbf{\Phi} - \ln \mathbf{\varphi}\)</span> <span class="comment"># Матрица невязок</span><br />
 <span class="math notranslate nohighlight">\(k := 1\)</span> <span class="comment"># Счетчик итераций</span><br />
 <strong>while</strong> <span class="math notranslate nohighlight">\(\lVert \mathbf{g} \rVert_2 &gt; \epsilon\)</span> <strong>and</strong> <span class="math notranslate nohighlight">\(k &lt; N_{iter}\)</span> <strong>do</strong> <span class="comment"># Цикл решения системы нелинейных уравнений</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{K} := \mathbf{K} \cdot \exp \left( - \mathbf{g} \right)\)</span>  <span class="comment"># Обновление матрицы основных переменных</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{F} := R \left( \mathbf{K}, \, \mathbf{z} \right)\)</span> <span class="comment"># Вектор мольных долей фаз</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{x} := \mathbf{z} \, / \left( \mathbf{F}^\top \left(\mathbf{K} - 1 \right) + 1 \right)\)</span> <span class="comment"># Компонентный состав референсной фазы</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{Y} := \mathbf{K} \cdot \mathbf{x}\)</span> <span class="comment"># Матрица компонентных составов нереференсных фаз</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{\Phi} := \phi \left( \mathbf{Y} \right)\)</span> <span class="comment"># Матрица коэффициентов летучести компонентов в нереференсных фазах</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{\varphi} := \phi \left( \mathbf{x} \right)\)</span> <span class="comment"># Вектор коэффициентов летучести компонентов в референсной фазе</span><br />
  <span class="math notranslate nohighlight">\(\mathbf{g} := \ln \mathbf{K} + \ln \mathbf{\Phi} - \ln \mathbf{\varphi}\)</span> <span class="comment"># Матрица невязок</span><br />
  <span class="math notranslate nohighlight">\(k := k + 1\)</span> <span class="comment"># Обновление счетчика итераций</span><br />
 <strong>end while</strong><br />
 <strong>if</strong> <span class="math notranslate nohighlight">\(k &lt; N_{iter}\)</span> <strong>then</strong><br />
  <strong>exit for</strong><br />
 <strong>end if</strong><br />
<strong>end for</strong></p>
</div>
<p>Таким образом, метод последовательных подстановок характеризуется наличием двух <code class="docutils literal notranslate"><span class="pre">while</span></code>-циклов: внутренний цикл используется для решения <a class="reference internal" href="SEC-2-RR.html"><span class="std std-doc">уравнения Речфорда-Райса</span></a> при фиксированных константах фазового равновесия, внешний цикл – для обновления констант фазового равновесия, исходя из необходимого условия равновесия.</p>
<p>В качестве начальных приближений констант фазового равновесия для расчета равновесного состояния можно использовать тот же набор начальных приближений, что и для <a class="reference internal" href="SEC-1-Stability.html"><span class="std std-doc">проверки стабильности системы</span></a>. Кроме того, в качестве начального приближения к определению равновесного состояния можно использовать результаты анализа стабильности, одним из которых является вектор <span class="math notranslate nohighlight">\(Y_i, \; i = 1 \, \ldots \, N_c,\)</span> интерепретируемый как вектор количеств вещества компонентов в системе. Тогда вектор</p>
<div class="math notranslate nohighlight">
\[ y_i = \frac{Y_i}{\sum_{j=1}^{N_c} Y_j}, \; i = 1 \, \ldots \, N_c, \]</div>
<p>представляет собой вектор мольных долей компонентов в системе. Следовательно, набор начальных приближений для расчета равновесного состояния:</p>
<div class="math notranslate nohighlight">
\[ \mathbf{K}_0 = \left\{ y_i \, / \, z_i, \; z_i  \, / \, y_i, \; i = 1 \, \ldots \, N_c \right\}. \]</div>
<p>После определения равновесного состояния для <span class="math notranslate nohighlight">\(N_p\)</span>-фазной постановки задачи выполняется анализ стабильности системы. Если анализ стабильности показывает, что <span class="math notranslate nohighlight">\(N_p\)</span>-фазный компонентный состав не является стабильным, то выполняется поиск равновесного состояния для <span class="math notranslate nohighlight">\(\left( N_p+1 \right)\)</span>-фазной постановки.</p>
<p>Рассмотрим применения метода последовательных подстановок для нахождения равновесного состояния. В данном подразделе будет использоваться <a class="reference internal" href="../2-EOS/EOS-2-SRK-PR.html"><span class="std std-doc">уравнение состояние Пенга-Робинсона</span></a> и его <a class="reference external" href="https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/eos.py">реализация</a>. Кроме того, для проверки стабильности системы будет применяться метод последовательных подстановок, алгоритм которого был рассмотрен <a class="reference internal" href="SEC-1-Stability.html"><span class="std std-doc">ранее</span></a>, реализованный <a class="reference external" href="https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/stability.py">здесь</a>. Также на каждой итерации решения системы уравнений термодинамического равновесия необходимо решать <a class="reference internal" href="SEC-2-RR.html"><span class="std std-doc">уравнение Речфорда-Райса</span></a>. Для решения уравнения в двухфазной постановке будет использоваться <a class="reference external" href="https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/rr.py">реализация</a> <a class="reference internal" href="SEC-3-RR-2P.html"><span class="std std-doc">метода FGH</span></a>, для решения системы уравнений Речфорда-Райса – модифицированный метод [<a class="reference external" href="https://doi.org/10.2118/117752-PA">Okuno et al, 2010</a>], реализация которого представлена <a class="reference external" href="https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/rr.py">здесь</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;../../_src/&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">eos</span> <span class="kn">import</span> <span class="n">pr78</span>
<span class="kn">from</span> <span class="nn">stability</span> <span class="kn">import</span> <span class="n">stabilityPT</span>
<span class="kn">from</span> <span class="nn">rr</span> <span class="kn">import</span> <span class="n">solve2p_FGH</span><span class="p">,</span> <span class="n">solveNp</span>
</pre></div>
</div>
</div>
</div>
<div class="exercise admonition">
<p class="admonition-title">Пример</p>
<p>Пусть имеется <span class="math notranslate nohighlight">\(1 \; моль\)</span> смеси из метана и диоксида углерода при температуре <span class="math notranslate nohighlight">\(10 \; ^{\circ} C\)</span> и давлении <span class="math notranslate nohighlight">\(6 \; МПа\)</span> с мольной долей метана <span class="math notranslate nohighlight">\(0.1\)</span>. Необходимо определить равновесное состояние системы.</p>
</div>
<p>Зададим исходные термобарические условия и компонентный состав.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">6e6</span><span class="p">)</span> <span class="c1"># Pressure [Pa]</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">10.</span> <span class="o">+</span> <span class="mf">273.15</span><span class="p">)</span> <span class="c1"># Temperature [K]</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.9</span><span class="p">,</span> <span class="mf">.1</span><span class="p">])</span> <span class="c1"># Mole fractions [fr.]</span>
</pre></div>
</div>
</div>
</div>
<p>Также зададим максимальное число итераций <span class="math notranslate nohighlight">\(N_{iter}\)</span>, точность решения системы нелинейных уравнений <span class="math notranslate nohighlight">\(\epsilon\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Niter</span> <span class="o">=</span> <span class="mi">50</span> <span class="c1"># Number of iterations</span>
<span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">)</span> <span class="c1"># Tolerance</span>
</pre></div>
</div>
</div>
</div>
<p>Зададим свойства компонентов, необходимые для уравнения состояния Пенга-Робинсона, и выполним инициализацию класса.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Pci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">7.37646</span><span class="p">,</span> <span class="mf">4.600155</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="c1"># Critical pressures [Pa]</span>
<span class="n">Tci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">304.2</span><span class="p">,</span> <span class="mf">190.6</span><span class="p">])</span> <span class="c1"># Critical temperatures [K]</span>
<span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.225</span><span class="p">,</span> <span class="mf">.008</span><span class="p">])</span> <span class="c1"># Acentric factors</span>
<span class="n">mwi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.04401</span><span class="p">,</span> <span class="mf">0.016043</span><span class="p">])</span> <span class="c1"># Molar mass [kg/gmole]</span>
<span class="n">vsi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span> <span class="c1"># Volume shift parameters</span>
<span class="n">dij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.025</span><span class="p">])</span> <span class="c1"># Binary interaction parameters</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">pr78</span><span class="p">(</span><span class="n">Pci</span><span class="p">,</span> <span class="n">Tci</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">mwi</span><span class="p">,</span> <span class="n">vsi</span><span class="p">,</span> <span class="n">dij</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Проиницилизируем класс для проведения теста стабильности и выполним проверку стабильности однофазного состояния:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stab</span> <span class="o">=</span> <span class="n">stabilityPT</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ss&#39;</span><span class="p">)</span>
<span class="n">stabres</span> <span class="o">=</span> <span class="n">stab</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
<span class="n">stabres</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The one-phase state is stable:
False
Tangent-plane distance:
-0.016542621413642863
Calculation completed successfully:
True
</pre></div>
</div>
</div>
</div>
<p>В результате проверки стабильности (путем вызова метода <code class="docutils literal notranslate"><span class="pre">run</span></code>) однофазное состояние системы оказалось нестабильным. Также был получен набор начальных приближений для проведения расчета равновесного состояния:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stabres</span><span class="o">.</span><span class="n">kvji</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([0.8777675 , 2.10009246]), array([1.13925384, 0.47616951]))
</pre></div>
</div>
</div>
</div>
<p>Создадим функцию, которая будет принимать на вход кортеж из результатов предыдущей итерации, точность и максимальное число итераций, и возвращать необходимость расчета следующей итерации цикла решения системы нелинейных уравнений теродинамического равновесия. Проиницилизируем данную функцию.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy.typing</span> <span class="k">as</span> <span class="nn">npt</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="k">def</span> <span class="nf">condit</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">Niter</span><span class="p">):</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">kvi</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">carry</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">Niter</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span>

<span class="n">pcondit</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">condit</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">Niter</span><span class="o">=</span><span class="n">Niter</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Также создадим функцию, которая будет принимать на вход результаты предыдущей итерации в виде кортежа, и рассчитывать результаты для новой итерации.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">update_ssi_2p</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">plnphi</span><span class="p">):</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">kvi_k</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gi_k</span> <span class="o">=</span> <span class="n">carry</span>
    <span class="n">kvi_kp1</span> <span class="o">=</span> <span class="n">kvi_k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gi_k</span><span class="p">)</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="n">solve2p_FGH</span><span class="p">(</span><span class="n">kvi_kp1</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
    <span class="n">y2i</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">F1</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvi_kp1</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="n">y1i</span> <span class="o">=</span> <span class="n">y2i</span> <span class="o">*</span> <span class="n">kvi_kp1</span>
    <span class="n">lnphi2i</span> <span class="o">=</span> <span class="n">plnphi</span><span class="p">(</span><span class="n">yi</span><span class="o">=</span><span class="n">y2i</span><span class="p">)</span>
    <span class="n">lnphi1i</span> <span class="o">=</span> <span class="n">plnphi</span><span class="p">(</span><span class="n">yi</span><span class="o">=</span><span class="n">y1i</span><span class="p">)</span>
    <span class="n">gi_kp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kvi_kp1</span><span class="p">)</span> <span class="o">+</span> <span class="n">lnphi1i</span> <span class="o">-</span> <span class="n">lnphi2i</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kvi_kp1</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">gi_kp1</span>

<span class="n">pupdate_ssi_2p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_ssi_2p</span><span class="p">,</span> <span class="n">yi</span><span class="o">=</span><span class="n">yi</span><span class="p">,</span> <span class="n">plnphi</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphii</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Найдем равновесное состояние с использованием метода последовательных подстановок:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kvi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stabres</span><span class="o">.</span><span class="n">kvji</span><span class="p">):</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="n">solve2p_FGH</span><span class="p">(</span><span class="n">kvi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
    <span class="n">y2i</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">F1</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvi</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="n">y1i</span> <span class="o">=</span> <span class="n">y2i</span> <span class="o">*</span> <span class="n">kvi</span>
    <span class="n">lnphi2i</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphii</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y2i</span><span class="p">)</span>
    <span class="n">lnphi1i</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphii</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y1i</span><span class="p">)</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kvi</span><span class="p">)</span> <span class="o">+</span> <span class="n">lnphi1i</span> <span class="o">-</span> <span class="n">lnphi2i</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kvi</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">gi</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">pcondit</span><span class="p">(</span><span class="n">carry</span><span class="p">):</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">pupdate_ssi_2p</span><span class="p">(</span><span class="n">carry</span><span class="p">)</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">kvi</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">carry</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Niter</span><span class="p">:</span>
        <span class="n">y2i</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">F1</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvi</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">y1i</span> <span class="o">=</span> <span class="n">y2i</span> <span class="o">*</span> <span class="n">kvi</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For the initial guess #</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">:</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">tolerance of equations: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">number of iterations: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">phase compositions:</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">y1i</span><span class="si">}</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">y2i</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">phase mole fractions: </span><span class="si">{</span><span class="n">F1</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="mf">1.</span><span class="o">-</span><span class="n">F1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">break</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>For the initial guess #0:
	tolerance of equations: 2.3732334650579942e-07
	number of iterations: 10
	phase compositions:
		[0.81827116 0.18172884]
		[0.91760692 0.08239308]
	phase mole fractions: 0.17724653136833962, 0.8227534686316604
</pre></div>
</div>
</div>
</div>
<p>Выполним проверку стабильности найденного решения:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stab</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y1i</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The one-phase state is stable:
True
Tangent-plane distance:
1.2806078420733526e-10
Calculation completed successfully:
True
</pre></div>
</div>
</div>
</div>
<p>Тест стабильности показал, что найденное решение соответствует равновесному состоянию. Проиллюстрируем данный пример графически. Для этого построим зависимость функции энергии Гиббса для первой фазы от компонентного состава и проведем касательную в точке с найденным равновесным составом этой фазы. Значения функции энергии Гиббса:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">yj1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">,</span> <span class="mf">0.9999</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">yji</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">yj1</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">yj1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="n">lnphiji</span><span class="p">,</span> <span class="n">Zj</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphiji_Zj</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">yji</span><span class="p">)</span>
<span class="n">lnfji</span> <span class="o">=</span> <span class="n">lnphiji</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">P</span> <span class="o">*</span> <span class="n">yji</span><span class="p">)</span>
<span class="n">Gj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vecdot</span><span class="p">(</span><span class="n">yji</span><span class="p">,</span> <span class="n">lnfji</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Уравнение касательной:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lnfi</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnfi</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y1i</span><span class="p">)</span>
<span class="n">Lj</span> <span class="o">=</span> <span class="n">yji</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lnfi</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Построение графиков функции энергии Гиббса и касательной:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">fig1</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yj1</span><span class="p">,</span> <span class="n">Gj</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;teal&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Приведенная добавочная энергия Гиббса&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yj1</span><span class="p">,</span> <span class="n">Lj</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;orchid&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Касательная&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Количество вещества диоксида углерода в системе, моль&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Приведенная добавочная энергия Гиббса&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">axins1</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">inset_axes</span><span class="p">([</span><span class="mf">0.04</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.89</span><span class="p">],</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="mf">0.65</span><span class="p">,</span> <span class="mf">0.975</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">15.1</span><span class="p">),</span>
                        <span class="n">xticklabels</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticklabels</span><span class="o">=</span><span class="p">[])</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">indicate_inset_zoom</span><span class="p">(</span><span class="n">axins1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yj1</span><span class="p">,</span> <span class="n">Gj</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;teal&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Приведенная добавочная</span><span class="se">\n</span><span class="s1">энергия Гиббса&#39;</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">yj1</span><span class="p">,</span> <span class="n">Lj</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;orchid&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Касательная&#39;</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y1i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y1i</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lnfi</span><span class="p">),</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">mec</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y2i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2i</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lnfi</span><span class="p">),</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">mfc</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">mec</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">y1i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y1i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">y1i</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lnfi</span><span class="p">)],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">y2i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2i</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="n">y2i</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lnfi</span><span class="p">)],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">14.55</span><span class="p">,</span> <span class="s1">&#39;$y_</span><span class="si">{CO_2}</span><span class="s1"> = 0.818$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">14.55</span><span class="p">,</span> <span class="s1">&#39;$y_</span><span class="si">{CO_2}</span><span class="s1"> = 0.918$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.8</span><span class="p">])</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">14.6</span><span class="p">,</span> <span class="mf">14.8</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">])</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">axins1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/a1745baf100b49ca8f07b12e02c234f6d1bd0723dd57e9834657e369d469d03c.png" src="../../_images/a1745baf100b49ca8f07b12e02c234f6d1bd0723dd57e9834657e369d469d03c.png" />
</div>
</div>
<p>Из данного графика следует, что касательная, проведенная к функции энергии Гиббса в точке с компонентным составом первой фазы, не имеет пересечений с самой функцией, что подтверждает сделанный вывод о равновесности найденного состояния. Кроме того, можно отметить, что касательная имеет две точки касания, абсциссы которых соответствуют равновесным компонентным составам фаз, то есть функция энергии Гиббса имеет одинаковую касательную для каждого из компонентных составов, определяющих стационарное состояние. Это следует из равенства летучестей соответствующих компонентов в фазах, а полное доказательство данного утверждения было рассмотрено <a class="reference internal" href="SEC-1-Stability.html"><span class="std std-doc">ранее</span></a>. Стоит также отметить, что две точки, показанные на графике, соответствующие двухфазному равновесному состоянию, называются <em><strong>бинодальными точками</strong></em>.</p>
<p>Таким образом, на примере, представленном выше, было рассмотрено применение метода последовательных подстановок для расчета равновесного состояния в двухфазной постановке. Однако этот метод может применяться и для многофазного случая. Рассмотрим следующий пример.</p>
<div class="exercise admonition">
<p class="admonition-title">Пример</p>
<p>Пусть имеется <span class="math notranslate nohighlight">\(1 \; моль\)</span> смеси из метана, гексана и воды при температуре <span class="math notranslate nohighlight">\(20 \; ^{\circ} C\)</span> и давлении <span class="math notranslate nohighlight">\(1 \; атм\)</span> с мольными долями компонентов <span class="math notranslate nohighlight">\(0.1, \, 0.6, \, 0.3\)</span> соответственно. Необходимо определить равновесное состояние системы.</p>
</div>
<p>Зададим исходные термобарические условия и компонентный состав.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">101325.</span><span class="p">)</span> <span class="c1"># Pressure [Pa]</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mf">20.</span> <span class="o">+</span> <span class="mf">273.15</span><span class="p">)</span> <span class="c1"># Temperature [K]</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.6</span><span class="p">,</span> <span class="mf">.3</span><span class="p">])</span> <span class="c1"># Mole fractions [fr.]</span>
</pre></div>
</div>
</div>
</div>
<p>Зададим свойства компонентов, необходимые для уравнения состояния Пенга-Робинсона, и выполним инициализацию класса.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Pci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.600155</span><span class="p">,</span> <span class="mf">3.2890095</span><span class="p">,</span> <span class="mf">22.04832</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e6</span> <span class="c1"># Critical pressures [Pa]</span>
<span class="n">Tci</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">190.6</span><span class="p">,</span> <span class="mf">507.5</span><span class="p">,</span> <span class="mf">647.3</span><span class="p">])</span> <span class="c1"># Critical temperatures [K]</span>
<span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.008</span><span class="p">,</span> <span class="mf">.27504</span><span class="p">,</span> <span class="mf">.344</span><span class="p">])</span> <span class="c1"># Acentric factors</span>
<span class="n">mwi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.016043</span><span class="p">,</span> <span class="mf">0.086</span><span class="p">,</span> <span class="mf">0.018015</span><span class="p">])</span> <span class="c1"># Molar mass [kg/gmole]</span>
<span class="n">vsi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span> <span class="c1"># Volume shift parameters</span>
<span class="n">dij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.0253</span><span class="p">,</span> <span class="mf">0.4907</span><span class="p">,</span> <span class="mf">0.48</span><span class="p">])</span> <span class="c1"># Binary interaction parameters</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">pr78</span><span class="p">(</span><span class="n">Pci</span><span class="p">,</span> <span class="n">Tci</span><span class="p">,</span> <span class="n">wi</span><span class="p">,</span> <span class="n">mwi</span><span class="p">,</span> <span class="n">vsi</span><span class="p">,</span> <span class="n">dij</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Проиницилизируем класс для проведения теста стабильности и выполним проверку стабильности однофазного состояния:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stab</span> <span class="o">=</span> <span class="n">stabilityPT</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ss&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># level=1 means more cases of initial k-values</span>
<span class="n">stabres</span> <span class="o">=</span> <span class="n">stab</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
<span class="n">stabres</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The one-phase state is stable:
False
Tangent-plane distance:
-1.073685357209667
Calculation completed successfully:
True
</pre></div>
</div>
</div>
</div>
<p>Однофазное состояние оказалось нестабильным, выполним расчет двухфазного равновесного состояния. Для этого сначала проинициализируем функцию <code class="docutils literal notranslate"><span class="pre">update_ssi_2p</span></code> для рассматриваемого примера. Поскольку точность расчета и максимальное количество итераций не изменилось, то будем использовать функцию <code class="docutils literal notranslate"><span class="pre">pcondit</span></code> из предыдущего примера:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pupdate_ssi_2p</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_ssi_2p</span><span class="p">,</span> <span class="n">yi</span><span class="o">=</span><span class="n">yi</span><span class="p">,</span> <span class="n">plnphi</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphii</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Перебирая различные начальные приближения констант фазового равновесия, полученные после проверки стабильности однофазного состояния, выполним расчет равновесного состояния в двухфазной постановке:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">kvi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stabres</span><span class="o">.</span><span class="n">kvji</span><span class="p">):</span>
    <span class="n">F1</span> <span class="o">=</span> <span class="n">solve2p_FGH</span><span class="p">(</span><span class="n">kvi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
    <span class="n">y2i</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">F1</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvi</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="n">y1i</span> <span class="o">=</span> <span class="n">y2i</span> <span class="o">*</span> <span class="n">kvi</span>
    <span class="n">lnphi2i</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphii</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y2i</span><span class="p">)</span>
    <span class="n">lnphi1i</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphii</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y1i</span><span class="p">)</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kvi</span><span class="p">)</span> <span class="o">+</span> <span class="n">lnphi1i</span> <span class="o">-</span> <span class="n">lnphi2i</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kvi</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">gi</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">pcondit</span><span class="p">(</span><span class="n">carry</span><span class="p">):</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">pupdate_ssi_2p</span><span class="p">(</span><span class="n">carry</span><span class="p">)</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">kvi</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">gi</span> <span class="o">=</span> <span class="n">carry</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Niter</span><span class="p">:</span>
        <span class="n">y2i</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">F1</span> <span class="o">*</span> <span class="p">(</span><span class="n">kvi</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">y1i</span> <span class="o">=</span> <span class="n">y2i</span> <span class="o">*</span> <span class="n">kvi</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;For the initial guess #</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">:</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">tolerance of equations: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">number of iterations: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">phase compositions:</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">y1i</span><span class="si">}</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">y2i</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">phase mole fractions: </span><span class="si">{</span><span class="n">F1</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="mf">1.</span><span class="o">-</span><span class="n">F1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">break</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>For the initial guess #0:
	tolerance of equations: 6.277521420841364e-07
	number of iterations: 5
	phase compositions:
		[0.00105886 0.98875662 0.01018452]
		[0.20198554 0.19928141 0.59873305]
	phase mole fractions: 0.507575898707777, 0.492424101292223
</pre></div>
</div>
</div>
</div>
<p>Метод последовательных подстановок нашел состояние, характеризующееся равенством летучестей соответствующих компонентов в фазах, за пять итераций. Проверим, является ли двухфазное состояние стабильным. Для этого проведем тест стабильности для одной из фаз:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stabres</span> <span class="o">=</span> <span class="n">stab</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">y2i</span><span class="p">)</span>
<span class="n">stabres</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The one-phase state is stable:
False
Tangent-plane distance:
-3.425189957136501
Calculation completed successfully:
True
</pre></div>
</div>
</div>
</div>
<p>По результатам проверки стабильности двухфазное равновесное состояние оказалось нестабильным, следовательно, необходимо выполнить расчет для трехфазного равновесного состояния. Остановимся подробнее на задании начального приближения для многофазного расчета равновесного состояния. Результатом двухфазного расчета равновесного состояния является некоторое состояние системы, характеризующиеся равенством летучестей соответствующих компонентов, компонентными составами фаз <span class="math notranslate nohighlight">\(y_{1i}, \, i = 1 \, \ldots \, N_c,\)</span> и <span class="math notranslate nohighlight">\(y_{2i}, \, i = 1 \, \ldots \, N_c,\)</span>, мольными долями фаз <span class="math notranslate nohighlight">\(F_1\)</span> и <span class="math notranslate nohighlight">\(F_2\)</span>, а также константами фазого равновесия <span class="math notranslate nohighlight">\(K_{1i} = y_{1i} \, / \, y_{2i}, \, i = 1 \, \ldots \, N_c\)</span>. Затем был проведен тест стабильности компонентного состава <span class="math notranslate nohighlight">\(y_{2i}, \, i = 1 \, \ldots \, N_c,\)</span> показавший его нестабильность, в ходе которого удалось подобрать некоторую мнимую фазу <em>(trial phase)</em> с компонентным составом <span class="math notranslate nohighlight">\(x_i, \, i = 1 \, \ldots \, N_c,\)</span> и константами фазового равновесия <span class="math notranslate nohighlight">\(K_{ti} = x_i \, / \, y_{2i}, \, i = 1 \, \ldots \, N_c,\)</span> также находящуюся в термодинамическом равновесии. Таким образом, набор констант фазового равновесия <span class="math notranslate nohighlight">\(\mathbf{K} = \left\{ K_{1i}, \, K_{ti} \right\}\)</span> является хорошим начальным приближением для расчета трехфазного равновесного состояния, согласно [<a class="reference external" href="https://doi.org/10.1016/j.fluid.2012.06.021">Li and Firoozabadi, 2012</a>]. При этом начальное приближение необходимо и для <a class="reference internal" href="SEC-4-RR-NP.html"><span class="std std-doc">алгоритма</span></a> решения системы уравнений Речфорда-Райса, в качестве которого может выступить вектор <span class="math notranslate nohighlight">\(\mathbf{F} = \left( F_1, \, 0 \right)^\top\)</span>, поскольку мнимая фаза характеризуется пренебрежимо малой мольной долей.</p>
<p>С учетом изложенного выше, сформируем матрицу констант фазового равновесия для первой итерации расчета трехфазного равновесного состояния:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kvji</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">kvi</span><span class="p">,</span> <span class="n">stabres</span><span class="o">.</span><span class="n">kvji</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">kvji</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[5.24225188e-03, 4.96160994e+00, 1.70101163e-02],
       [1.09678556e-10, 1.37290196e-21, 1.67019342e+00]])
</pre></div>
</div>
</div>
</div>
<p>Определим мольные доли фаз, соответствующие этому начальному приближению:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Fj</span> <span class="o">=</span> <span class="n">solveNp</span><span class="p">(</span><span class="n">kvji</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">F1</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]))</span>
<span class="n">Fj</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([0.5075759, 0.       ])
</pre></div>
</div>
</div>
</div>
<p>Рассчитаем компонентные составы фаз:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xi</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">Fj</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kvji</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">yji</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">*</span> <span class="n">kvji</span>
</pre></div>
</div>
</div>
</div>
<p>Выполним расчет коэффициентов летучестей для каждого компонента в каждой из фаз. Для этого воспользуемся методом <code class="docutils literal notranslate"><span class="pre">get_lnphiji_Zj</span></code> класса <code class="docutils literal notranslate"><span class="pre">pr</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lnphiji</span><span class="p">,</span> <span class="n">Zj</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphiji_Zj</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">yji</span><span class="p">,</span> <span class="n">xi</span><span class="p">]))</span>
</pre></div>
</div>
</div>
</div>
<p>Рассчитаем матрицу невязок:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gji</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kvji</span><span class="p">)</span> <span class="o">+</span> <span class="n">lnphiji</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lnphiji</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Создадим функцию, которая будет получать на вход результаты предыдущей итерации и возвращать результаты следующей итерации метода последовательных подстановок:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update_ssi_Np</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">plnphi</span><span class="p">):</span>
    <span class="n">k</span><span class="p">,</span> <span class="n">kvji_k</span><span class="p">,</span> <span class="n">Fj0</span><span class="p">,</span> <span class="n">gji_k</span> <span class="o">=</span> <span class="n">carry</span>
    <span class="n">kvji_kp1</span> <span class="o">=</span> <span class="n">kvji_k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gji_k</span><span class="p">)</span>
    <span class="n">Fj</span> <span class="o">=</span> <span class="n">solveNp</span><span class="p">(</span><span class="n">kvji_kp1</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">Fj0</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">Fj</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kvji_kp1</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="n">yji</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">*</span> <span class="n">kvji_kp1</span>
    <span class="n">lnphiji</span><span class="p">,</span> <span class="n">Zj</span> <span class="o">=</span> <span class="n">plnphi</span><span class="p">(</span><span class="n">yji</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">yji</span><span class="p">,</span> <span class="n">xi</span><span class="p">]))</span>
    <span class="n">gji_kp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">kvji_kp1</span><span class="p">)</span> <span class="o">+</span> <span class="n">lnphiji</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lnphiji</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kvji_kp1</span><span class="p">,</span> <span class="n">Fj</span><span class="p">,</span> <span class="n">gji_kp1</span>

<span class="n">pupdate_ssi_Np</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_ssi_Np</span><span class="p">,</span> <span class="n">yi</span><span class="o">=</span><span class="n">yi</span><span class="p">,</span> <span class="n">plnphi</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">getPT_lnphiji_Zj</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>В цикле <code class="docutils literal notranslate"><span class="pre">while</span></code> выполним расчет трехфазного равновесного состояния:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kvji</span><span class="p">,</span> <span class="n">Fj</span><span class="p">,</span> <span class="n">gji</span><span class="p">)</span>

<span class="k">while</span> <span class="n">pcondit</span><span class="p">(</span><span class="n">carry</span><span class="p">):</span>
    <span class="n">carry</span> <span class="o">=</span> <span class="n">pupdate_ssi_Np</span><span class="p">(</span><span class="n">carry</span><span class="p">)</span>

<span class="n">k</span><span class="p">,</span> <span class="n">kvji</span><span class="p">,</span> <span class="n">Fj</span><span class="p">,</span> <span class="n">gji</span> <span class="o">=</span> <span class="n">carry</span>

<span class="n">xi</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">/</span> <span class="p">(</span><span class="n">Fj</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">kvji</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">yji</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xi</span> <span class="o">*</span> <span class="n">kvji</span><span class="p">,</span> <span class="n">xi</span><span class="p">])</span>
<span class="n">Fj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Fj</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">Fj</span><span class="o">.</span><span class="n">sum</span><span class="p">()])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Tolerance of equations: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gji</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="sa">f</span><span class="s1">&#39;Number of iterations: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="sa">f</span><span class="s1">&#39;Phase compositions:</span><span class="se">\n</span><span class="si">{</span><span class="n">yji</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
      <span class="sa">f</span><span class="s1">&#39;Phase mole fractions: </span><span class="si">{</span><span class="n">Fj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tolerance of equations: 6.812285134095091e-07
Number of iterations: 4
Phase compositions:
[[4.06762255e-03 9.95611408e-01 3.20969086e-04]
 [2.61399710e-09 8.46398046e-21 9.99999997e-01]
 [7.79541589e-01 2.01162115e-01 1.92962958e-02]]
Phase mole fractions: [0.57733451 0.29739749 0.12526801]
</pre></div>
</div>
</div>
</div>
<p>Выполним проверку стабильности компонентного состава одной из фаз:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">stab</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">yji</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The one-phase state is stable:
True
Tangent-plane distance:
6.124767359968357e-12
Calculation completed successfully:
True
</pre></div>
</div>
</div>
</div>
<p>Таким образом, на представленных примерах было продемонстрировано применение метода последовательных подстановок для нахождения двух- и трехфазного равновесного состояния. Как уже было отмечено ранее, недостатком этого метода является сравнительно большое количество итераций и медленная сходимость для случаев вблизи <a class="reference internal" href="SEC-6-Saturation.html"><span class="std std-doc">линии насыщения</span></a> или вблизи <a class="reference internal" href="SEC-7-Criticality.html"><span class="std std-doc">критической точки</span></a>. Для ускорения могут применяться различные модификации данного метода, полученные авторами работ [<a class="reference external" href="https://doi.org/10.1002/cjce.5450610414">Mehra et al, 1983</a>; <a class="reference external" href="https://doi.org/10.1016/0378-3812(84)80013-8">Nghiem and Li, 1984</a>]. Реализация метода <em>QNSS</em> представлена <a class="reference external" href="https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/flash.py">здесь</a>.</p>
<p>Особенностью данных методов является введение коэффициента <em>длины шага итерации</em>, обозначенного в представленном выше алгоритме, как <span class="math notranslate nohighlight">\(\lambda\)</span>, и его расчет с использованием следующего выражения:</p>
<div class="math notranslate nohighlight">
\[ \lambda^{k} = \lambda^{k-1} \frac{\left( \mathbf{g}^\top \mathbf{g} \right)^{k-1}}{\left( \mathbf{g}^\top \mathbf{g} \right)^{k-1} - {\mathbf{g}^{k-1}}^\top \mathbf{g}^k}, \]</div>
<p>а итерация записывается следующим образом:</p>
<div class="math notranslate nohighlight">
\[ \ln \mathbf{k}^{k+1} = \ln \mathbf{k}^k - \lambda^k \mathbf{g}^k. \]</div>
<p>Стоит отметить, что в обоих случаях предполагается выполнение первой итерации с использованием метода последовательных подстановок, то есть <span class="math notranslate nohighlight">\(\lambda^0 = 1\)</span>. Оба метода могут быть распространены и на многофазные системы. В этом случае, например, вектор <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> записывается следующим образом:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \mathbf{g} = \begin{bmatrix} \ln k_{11} + \ln \varphi_{11} - \ln \varphi_{N_p1} \\ \ln k_{12} + \ln \varphi_{12} - \ln \varphi_{N_p2} \\ \vdots \\ \ln k_{1N_c} + \ln \varphi_{1N_c} - \ln \varphi_{N_pN_c} \\ \ln k_{21} + \ln \varphi_{21} - \ln \varphi_{N_p1} \\ \ln k_{22} + \ln \varphi_{22} - \ln \varphi_{N_p2} \\ \vdots \\ \ln k_{2N_c} + \ln \varphi_{2N_c} - \ln \varphi_{N_pN_c} \\ \vdots \\ \ln k_{N_p-1,N_c} + \ln \varphi_{N_p-1,N_c} - \ln \varphi_{N_pN_c} \end{bmatrix}. \end{split}\]</div>
<p>Аналогично записывается вектор основных переменных. С другой стороны, поскольку метод последовательных подстановок является своеобразным упрощением метода градиентного спуска при рассмотрении задачи с точки зрения минимизации энергии Гиббса, то очевидным вариантом ускорения является применение метода Ньютона, требующего нахождение вторых частных производных функции энергии Гиббса по основным переменным. В качестве вектора основных переменных может выступать вектор количеств вещества компонентов в <span class="math notranslate nohighlight">\(\left( N_p-1 \right)\)</span> фазах.</p>
<p>Рассмотрим формулировку метода Ньютона для минимизации энергии Гиббса в двухфазной постановке. В качестве вектора основных переменных выберем вектор количеств вещества компонентов в жидкой фазе <span class="math notranslate nohighlight">\(n_{Li}, \, i = 1 \, \ldots \, N_c\)</span>. Элемент вектора количеств вещества компонентов в газовой фазе обозначим <span class="math notranslate nohighlight">\(n_{Vi}, \, i = 1 \, \ldots \, N_c\)</span>. При этом количество вещества компонента в газовой фазе выражается через количество вещества компонента в системе <span class="math notranslate nohighlight">\(n_i, \, i = 1 \, \ldots \, N_c,\)</span> и количество вещества компонента в жидкой фазе следующим образом:</p>
<div class="math notranslate nohighlight">
\[ n_{Vi} = n_i - n_{Li}, \; i = 1 \, \ldots \, N_c. \]</div>
<p>Количество вещества жидкой и газовой фаз можно получить через количество вещества <span class="math notranslate nohighlight">\(i\)</span>-го компонента:</p>
<div class="math notranslate nohighlight">
\[ n_L = \sum_{i = 1}^{N_c} n_{Li}, \; n_V = \sum_{i = 1}^{N_c} n_{Vi}. \]</div>
<p>Для метода Ньютона необходимо получение аналитических выражений вектора градиента энергии Гиббса и матрицы гессиана. Выражение для элемента вектора градиента приведенной (безразмерной) энергии Гиббса было рассмотрено <a class="reference internal" href="SEC-1-Stability.html"><span class="std std-doc">ранее</span></a>:</p>
<div class="math notranslate nohighlight">
\[ g_i = \ln f_{Li} - \ln f_{Vi}, \; i = 1 \, \ldots \, N_c. \]</div>
<p>Выразим летучесть <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(j\)</span>-й фазе через коэффициент летучести и его количество вещества:</p>
<div class="math notranslate nohighlight">
\[ \ln f_{ji} = \ln \varphi_{ji} y_{ji} P = \ln \varphi_{ji} \frac{n_{ji}}{n_j} P = \ln \varphi_{ji} + \ln n_{ji} - \ln n_j + \ln P, \; j = \left\{L, \, V \right\}, \; i = 1 \, \ldots \, N_c. \]</div>
<p>Тогда элемент вектора градиента:</p>
<div class="math notranslate nohighlight">
\[ g_i = \ln \varphi_{Li} + \ln n_{Li} - \ln n_L - \left( \ln \varphi_{Vi} + \ln n_{Vi} - \ln n_V \right), \; i = 1 \, \ldots \, N_c. \]</div>
<p>Получим выражение для элемента матрицы гессиана:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{alignat}{1}
H_{il}
&amp;= &amp;&amp; \frac{\partial g_i}{\partial n_{Ll}} \\
&amp;= &amp;&amp; \frac{\partial \ln \varphi_{Li}}{\partial n_{Ll}} + \frac{\partial \ln n_{Li}}{\partial n_{Ll}} - \frac{\partial \ln n_L}{\partial n_{Ll}} - \left( \frac{\partial \ln \varphi_{Vi}}{\partial n_{Vl}} \frac{\partial n_{Vl}}{\partial n_{Ll}} + \frac{\ln n_{Vi}}{\partial n_{Vl}} \frac{\partial n_{Vl}}{\partial n_{Ll}} - \frac{\partial \ln n_V}{\partial n_{Vl}} \frac{\partial n_{Vl}}{\partial n_{Ll}} \right), \\
&amp;&amp;&amp; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c.
\end{alignat} \end{split}\]</div>
<p>Упростим некоторые слагаемые. Частная производная логарифма количества вещества <span class="math notranslate nohighlight">\(i\)</span>-го компонента в <span class="math notranslate nohighlight">\(L\)</span>-й фазе по количесту вещества <span class="math notranslate nohighlight">\(l\)</span>-го компонента в этой же фазе:</p>
<div class="math notranslate nohighlight">
\[ \frac{\partial \ln n_{Li}}{\partial n_{Ll}} = \frac{1}{n_{Li}} \frac{\partial n_{Li}}{\partial n_{Ll}} = \frac{1}{n_{Li}} \delta_{il}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c, \]</div>
<p>где <span class="math notranslate nohighlight">\(\delta_{il}, \, i = 1 \, \ldots \, N_c, \, l = 1 \, \ldots \, N_c,\)</span> представляет собой элемент <a class="reference external" href="https://en.wikipedia.org/wiki/Identity_matrix">единичной матрицы</a> – <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_delta">дельта Кронекера</a>.</p>
<p>Частная производная количества вещества фазы <span class="math notranslate nohighlight">\(L\)</span> по количеству вещества <span class="math notranslate nohighlight">\(l\)</span>-го компонента этой же фазы:</p>
<div class="math notranslate nohighlight">
\[ \frac{\partial \ln n_L}{\partial n_{Ll}} = \frac{1}{n_L} \frac{\partial n_L}{\partial n_{Ll}} = \frac{1}{n_L} \frac{\partial}{\partial n_{Ll}} \sum_{i=1}^{N_c} n_{Li} = \frac{1}{n_L} \sum_{i=1}^{N_c} \frac{\partial n_{Li}}{\partial n_{Ll}} = \frac{1}{n_L}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c. \]</div>
<p>Частная производная количества вещества <span class="math notranslate nohighlight">\(l\)</span>-го компонента в <span class="math notranslate nohighlight">\(V\)</span>-й фазе по количеству вещества этого же компонента в фазе <span class="math notranslate nohighlight">\(L\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \frac{\partial n_{Vl}}{\partial n_{Ll}} = \frac{\partial}{\partial n_{Ll}} \left( n_l - n_{Ll} \right) = -1, \; l = 1 \, \ldots \, N_c. \]</div>
<p>С учетом изложенного выше элемент матрицы гессиана преобразуется к следующему виду:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align}
H_{il}
&amp;= \frac{\partial \ln \varphi_{Li}}{\partial n_{Ll}} + \frac{\partial \ln \varphi_{Vi}}{\partial n_{Vl}} + \delta_{il} \left( \frac{1}{n_{Li}} + \frac{1}{n_{Vi}} \right) - \left( \frac{1}{n_L} + \frac{1}{n_V} \right), \\
&amp;= \frac{\partial \ln \varphi_{Li}}{\partial n_{Ll}} + \frac{\partial \ln \varphi_{Vi}}{\partial n_{Vl}} + \delta_{il} \frac{n_i}{n_{Li} n_{Vi}} - \frac{n}{n_L n_V} \\
&amp;= \Phi_{il} + U_{il}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c,
\end{align} \end{split}\]</div>
<p>где:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\Phi_{il} &amp;= \frac{\partial \ln \varphi_{Li}}{\partial n_{Ll}} + \frac{\partial \ln \varphi_{Vi}}{\partial n_{Vl}}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c, \\
U_{il} &amp;= \delta_{il} \frac{n_i}{n_{Li} n_{Vi}} - \frac{n}{n_L n_V} = \frac{1}{n_L n_V} \left( \delta_{il} \frac{n_i}{y_{Li} y_{Vi}} - n \right), \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c.
\end{align} \end{split}\]</div>
<p>Если рассматривается система с <span class="math notranslate nohighlight">\(n = 1 \, моль\)</span>, тогда выражение для элемента матрицы <span class="math notranslate nohighlight">\(\mathbf{U}\)</span>:</p>
<div class="math notranslate nohighlight">
\[ U_{il} = \frac{1}{F_L F_V} \left(  \frac{\delta_{il}}{u_i} - 1 \right), \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c, \]</div>
<p>где <span class="math notranslate nohighlight">\(u_i = y_{Li} y_{Vi} \, / \, y_i\)</span>.</p>
<p>Причем матрица <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> в данном выражении – это та же матрица <span class="math notranslate nohighlight">\(\mathbf{U}\)</span> в выражении для итерации метода градиентного спуска при минимизации энергии Гиббса относительно основных переменных, выраженных в виде логарифмов констант фазового равновесия. Частные производные логарифмов коэффициентов летучести компонентов могут быть получены с использованием средств <a class="reference external" href="https://en.wikipedia.org/wiki/Automatic_differentiation">автоматического дифференцирования</a> при использовании, например, библиотеки <a class="reference external" href="https://jax.readthedocs.io/en/latest/index.html">JAX</a>, либо воспользовавшись аналитическими выражениями для нахождения производных, полученными <a class="reference internal" href="../2-EOS/EOS-Appendix-A-PD.html"><span class="std std-doc">ранее</span></a> для кубических уравнений состояния.</p>
<p>Таким образом, <a class="reference internal" href="../../0-Math/0-LAB/LAB-10-LinearSystems.html"><span class="doc std std-doc">система линейных уравнений</span></a> при рассмотрении проблемы поиска равновесеного состояния, как задачи минимизации энергии Гиббса, и при использовании метода Ньютона относительно количеств вещества компонентов в фазе <span class="math notranslate nohighlight">\(L\)</span> записывается в следующем виде:</p>
<div class="math notranslate nohighlight">
\[ \mathbf{H}^k \Delta \mathbf{n}_L^k = \mathbf{g}^k, \]</div>
<p>где <span class="math notranslate nohighlight">\(k\)</span> – номер итерации. Эта система линейных уравнений разрешается относительно <span class="math notranslate nohighlight">\(\Delta \mathbf{n}_L^k\)</span> и впоследствии используется в итерации метода Ньютона:</p>
<div class="math notranslate nohighlight">
\[ \mathbf{n}_L^{k+1} = \mathbf{n}_L^{k} - \Delta \mathbf{n}_L^k, \]</div>
<p>Однако метод Ньютона также можно использовать, если выбрать логарифмы констант фазового равновесия в качестве основных переменных. В этом случае система линейных уравнений и итерация минимизации энергии Гиббса записываются следующим образом:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align}
&amp; \mathbf{J}^k \Delta \ln \mathbf{k}^k = \mathbf{g}^k, \\
&amp; \ln \mathbf{k}^{k+1} = \ln \mathbf{k}^{k} - \Delta \ln \mathbf{k}^k,
\end{align} \end{split}\]</div>
<p>где <span class="math notranslate nohighlight">\(\mathbf{J}^k = \left( \mathbf{H} \mathbf{U}^{-1} \right)^k.\)</span></p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition- admonition">
<p class="admonition-title">Дополнительно</p>
<p>Число обусловленности некоторой матрицы <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> является ее свойством и, грубо говоря, характеризует то, насколько сильно изменится решение системы линейных уравнений <span class="math notranslate nohighlight">\(\mathbf{A} \mathbf{x} = \mathbf{b}\)</span> при некотором изменении вектора <span class="math notranslate nohighlight">\(\mathbf{b}\)</span>. При больших значениях числа обусловленности даже небольшие изменения вектора <span class="math notranslate nohighlight">\(\mathbf{b}\)</span> могут вызвать существенные изменения вектора <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>, поэтому если число обусловленности матрицы <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> невелико, то такая матрица называется <em>хорошо обусловленной (well-conditioned)</em>, и наоборот при большом числе обусловленности матрица называется <em>плохо обусловленной (ill-conditioned)</em>. Подробнее данное свойство матриц было рассмотрено <a class="reference internal" href="../../0-Math/0-LAB/LAB-11-ConditionNumber.html"><span class="std std-doc">ранее</span></a>.</p>
</div>
</aside>
<p>Очевидным преимуществом использования вектора количеств вещества компонентов в качестве основных переменных является отсутствие необходимости решения уравнения (или системы уравнений) Речфорда-Райса: в этом случае мольные доли компонентов в фазах и мольные доли фаз могут быть получены напрямую из вектора основных переменных. С другой стороны, преимуществом использования логарифмов констант фазового равновесия в качестве основных переменных является то обстоятельство, что матрица <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> характеризуется меньшим значением <a class="reference external" href="https://en.wikipedia.org/wiki/Condition_number">числа обусловленности</a>, по сравнению с матрицей <span class="math notranslate nohighlight">\(\mathbf{H}\)</span>, то есть матрица <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> является хорошо обусловленной [<a class="reference external" href="https://doi.org/10.1016/j.fluid.2014.11.017">Petitfrere and Nichita, 2015</a>].</p>
<!-- TODO: Показать изменение числа обусловленности матриц J и H в зависимости от давления. См.: 10.1016/j.fluid.2014.11.017. -->
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition- admonition">
<p class="admonition-title">Дополнительно</p>
<p>Однако не следует использовать метод решения системы линейных уравнений через нахождение обратной матрицы (по крайней мере, для матриц с размерностью 4 и более, для которых получение аналитических выражений для решения проблематично). Подробнее об этом можно прочитать <a class="reference external" href="https://gregorygundersen.com/blog/2020/12/09/matrix-inversion/">здесь</a> и <a class="reference internal" href="../../0-Math/0-LAB/LAB-10-LinearSystems.html"><span class="std std-doc">здесь</span></a>.</p>
</div>
</aside>
<p>В обоих случаях на каждой итерации метода Ньютона требуется решение системы линейных уравнений для нахождения изменения основных переменных. Для этого могут применяться как <a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_decomposition">прямые</a>, так и <a class="reference external" href="https://en.wikipedia.org/wiki/Iterative_method#Linear_systems">итеративные методы решения</a>. Обе группы методов решения системы линейных уравнений рассматривались <a class="reference internal" href="../../0-Math/0-LAB/LAB-10-LinearSystems.html"><span class="std std-doc">ранее</span></a>. Для систем с небольшим количеством компонентов, которые чаще всего и встречаются в гидродинамическом моделировании, рекомендуется применение прямых методов, основанных на <a class="reference internal" href="../../0-Math/0-LAB/LAB-9-Decomposition.html"><span class="std std-doc">разложении матриц</span></a>.</p>
<p>Гессиан энергии Гиббса, элемент которого для рассматриваемого случая определяется выражением</p>
<div class="math notranslate nohighlight">
\[ H_{il} = \frac{\partial^2 G}{\partial n_{Li} \partial n_{Ll}}, \]</div>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition- admonition">
<p class="admonition-title">Дополнительно</p>
<p>Если гессиан не является положительно определенной матрицей, то вектор изменения основных переменных может представлять собой не направление спуска, а направление к седловой точке или даже направление к максимуму. Подробнее – в разделе, посвященном <a class="reference internal" href="../../0-Math/1-OM/OM-0-Introduction.html"><span class="std std-doc">методам оптимизации функции</span></a>.</p>
</div>
</aside>
<p>представляет собой симметричную матрицу, которая в окресности решения является положительно определенной. Однако поскольку начальное приближение констант фазового равновесия может быть произвольным, то положительная определенность гессиана негарантирована. В качестве метода решения системы линейных уравнений в работе [<a class="reference external" href="https://doi.org/10.1016/0378-3812(82)85002-4">Michelsen, 1982</a>] рекомендуется применение <a class="reference external" href="https://doi.org/10.1137/0911064">модифицированного разложения Шолески</a>, которое позволяет определить минимальное изменение <span class="math notranslate nohighlight">\(\mathbf{E}\)</span> матрицы <span class="math notranslate nohighlight">\(\mathbf{H}\)</span>, гарантирующее положительную определенность матрицы <span class="math notranslate nohighlight">\(\mathbf{H} + \mathbf{E}\)</span>, и представить полученный результат в виде произведения двух нижнетреугольных матриц: <span class="math notranslate nohighlight">\(\mathbf{H} + \mathbf{E} = \mathbf{L}\mathbf{L}^\top\)</span>. При этом, если матрица <span class="math notranslate nohighlight">\(\mathbf{H}\)</span> является положительно определенной, то <span class="math notranslate nohighlight">\(\mathbf{E} = 0\)</span>. Затем, зная нижнетреугольную матрицу, определяется вектор изменения основных переменных. Подробнее применение разложений для решения систем линейных уравнений рассматривалось <a class="reference internal" href="../../0-Math/0-LAB/LAB-10-LinearSystems.html"><span class="std std-doc">ранее</span></a>.</p>
<p>В случае использования логарифмов констант фазового равновесия система линейных уравнений записывается относительно якобиана <span class="math notranslate nohighlight">\(\mathbf{J}\)</span>. Поскольку матрица <span class="math notranslate nohighlight">\(\mathbf{J}\)</span> не является симметричной, то для разрешения системы линейных уравнений можно использовать <a class="reference external" href="https://en.wikipedia.org/wiki/LU_decomposition">LU-разложение</a>. Подробнее это также рассматривалось разделе, посвященном изучению <a class="reference internal" href="../../0-Math/0-LAB/LAB-10-LinearSystems.html"><span class="std std-doc">способов решения системы линейных уравнений</span></a>. Однако, согласно [<a class="reference external" href="https://doi.org/10.1016/j.fluid.2014.11.017">Petitfrere and Nichita, 2015</a>], время, необходимое на решение системы линейных уравнений будет в два раза меньше, по сравнению с LU-разложением, если сначала определить <span class="math notranslate nohighlight">\(\Delta \mathbf{n}_L\)</span> с использованием представленного выше способа, а затем вычислить <span class="math notranslate nohighlight">\(\Delta \ln \mathbf{k}\)</span>, воспользовавшись соотношением:</p>
<div class="math notranslate nohighlight">
\[ \Delta \ln \mathbf{k}^k = \mathbf{U}^k \Delta \mathbf{n}_L^k. \]</div>
<!-- TODO: Показать изменение количества итераций с ростом давления для методов последовательных подстановок, Ньютона с гессианом H и Ньютона с якобианом J. См.: 10.1016/j.fluid.2014.11.017. Показать, почему метод последовательных подстановок плохо сходится вблизи линии насыщения или критической точки. -->
<!-- TODO: Показать пример, где метод Ньютона не сходится к решению из-за плохого начального приближения и неположительно определенной матрицы гессиана. Показать, как для этой задачи будет работать метод Ньютона с модифицированным разложением Шолески. -->
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition- admonition">
<p class="admonition-title">Дополнительно</p>
<p>Алгоритмы оптимизации могут быть классифицированы по порядку производной целевой функции, которую они используют в расчете изменения основных переменных. Так, например, метод градиентного спуска использует производные первого порядка целевой функции (градиент), поэтому его относят к методам первого порядка. Метод Ньютона использует производные второго порядка целевой функции (гессиан), поэтому он относится к методам второго порядка. Существуют также и алгоритмы нулевого порядка, при применении которых производные вообще не используются <em>(derivative-free methods)</em>. При этом порядок алгоритма <em>(order of an algorithm)</em> в теории соотносится с порядком (скоростью) сходимости <em>(rate of convergence)</em>, однако, зачастую, это справедливо только вблизи решения (подробнее рассматривалось в <a class="reference internal" href="../../0-Math/1-OM/OM-0-Introduction.html"><span class="std std-doc">разделе про методы оптимизации функций</span></a>). Реальная же скорость сходимости зависит от начального приближения, вида оптимизируемой функции и др. На практике для оценки скорости сходимости используют <a class="reference external" href="https://en.wikipedia.org/wiki/Rate_of_convergence#Order_estimation">это</a> выражение.</p>
</div>
</aside>
<p>Другим решением проблемы негарантированной положительной определенности гессиана является поиск хорошего начального приближения. В связи с этим различными авторами рассматривается комбинированное использование метода последовательных подстановок (и его улучшенных альтернатив) и метода Ньютона. В этом случае метод последовательных подстановок используется на нескольких начальных итерациях с целью улучшения начального приближения, после чего происходит переключение на метод Ньютона. Естественно, проверять на каждой итерации является ли гессиан положительно определенной матрицей, является излишне ресурсозатратным. В связи с этим различными авторами были предложены косвенные условия, характеризующие о возможности перехода на использование методов второго порядка. Так, например, авторами работы [<a class="reference external" href="https://doi.org/10.2118/9232-PA">Mehra et al, 1982</a>] были предложены следующие критерии для переключения:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{cases}
\sum_{j=1}^{N_p-1} \sum_{i=1}^{N_c} g_{ji} \leq 10^{-4}, \\
\max_j \left| \frac{F_j^k - F_j^{k-1}}{F_j^{k-1}} \right| \leq 0.01 \lambda^k, \\
\sum_{j=1}^{N_p-1} L_j^2 \leq 10^{-8},
\end{cases} \end{split}\]</div>
<p>где</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align}
&amp; g_{ji} = \ln K_{ji} + \ln \varphi_{ji} - \ln \varphi_{N_pi}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c, \\
&amp; L_j = \sum_{i=1}^{N_c} \left( y_{ji} - y_{N_pi} \right), \; j = 1 \, \ldots \, N_p - 1.
\end{align} \end{split}\]</div>
<p>Несколько иные условия переключения на методы второго порядка были предложены авторами работы [<a class="reference external" href="https://doi.org/10.2118/8285-PA">Nghiem et al, 1983</a>]:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{cases}
\frac{\left( \mathbf{g}^\top \mathbf{g} \right)^k}{\left( \mathbf{g}^\top \mathbf{g} \right)^{k-1}} &gt; \epsilon_R, \\
\left| F_V^k - F_V^{k-1} \right| &lt; \epsilon_V, \\
\epsilon_L &lt; \left( \mathbf{g}^\top \mathbf{g} \right)^k &lt; \epsilon_U, \\
0 &lt; F_V^k &lt; 1.
\end{cases} \end{split}\]</div>
<p>Первые два критерия свидетельствуют о медленной сходимости метода последовательных подстановок. Третий критерий показывает диапазон длины вектора невязок, при котором, по мнению авторов, наиболее рационально. Верхняя граница диапазона предотвращает преждевременное переключение на методы второго порядка. Несмотря на то что вблизи решения порядок сходимости метода Ньютона превышает порядок сходимости метода градиентного спуска, переключение с одного метода на другой не является целесообразным непосредственно вблизи решения. Наконец, последний критерий не допускает переключение на метод Ньютона, когда значения мольной доли одной из фаз равны нулю, принимая во внимание особенности задания начальных приближений, а также выражение для матрицы <span class="math notranslate nohighlight">\(\mathbf{U}\)</span>. Типовые значения параметров: <span class="math notranslate nohighlight">\(\epsilon_R = 0.6, \, \epsilon_V = 10^{-2}, \, \epsilon_L = 10^{-5}, \, \epsilon_U = 10^{-3}\)</span>.</p>
<!-- TODO: Для этого же примера показать, как работает комбинированный метод с условиями переключения. -->
<p>Третьим решением проблемы негарантированной положительной определенности матрицы гессиана является применение квази-ньютоновских методов, которые вместо гессиана <span class="math notranslate nohighlight">\(\mathbf{H}\)</span> используют его аппроксимацию <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>, являющуюся гарантированно положительно определенной (стоит отметить, что не все квази-ньютоновские методы могут это гарантировать). Одним из таких алгоритмов является <a class="reference external" href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm">метод <em>BFGS</em></a>, рассмотренный <a class="reference internal" href="../../0-Math/1-OM/OM-0-Introduction.html"><span class="std std-doc">ранее</span></a>. Применение метода <em>BFGS</em> для расчета фазового равновесия и анализа стабильности рассматривалось авторами работ [<a class="reference external" href="https://doi.org/10.1002/aic.690330606">Ammar and Renon, 1987</a>; <a class="reference external" href="https://doi.org/10.1016/j.fluid.2015.07.035">Nichita and Petitfrere</a>]. Данный метод основан на следующей аппроксимации гессиана на <span class="math notranslate nohighlight">\(\left( k + 1 \right)\)</span>-й итерации:</p>
<div class="math notranslate nohighlight">
\[ \mathbf{B}^{k+1} = \mathbf{B}^k + \frac{\left(\mathbf{y} \mathbf{y}^\top \right)^k}{\left(\mathbf{y}^\top \mathbf{p}\right)^k} - \frac{\left( \mathbf{B} \mathbf{p} \left( \mathbf{B} \mathbf{p} \right)^\top \right)^k}{\left( \mathbf{p}^\top \mathbf{B} \mathbf{p} \right)^k}, \]</div>
<p>где:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align} \mathbf{y}^k &amp;= \mathbf{g}^k - \mathbf{g}^{k-1}, \\ \mathbf{p}^k &amp;= \mathbf{n}_L^k - \mathbf{n}_L^{k-1}. \end{align} \end{split}\]</div>
<p>В этом случае изменение основных переменных, количеств вещества жидкой фазы, записывается следующим образом:</p>
<div class="math notranslate nohighlight">
\[ \mathbf{n}_L^{k+1} = \mathbf{n}_L^{k} - \lambda \left( \mathbf{B}^{-1} \mathbf{g} \right)^k, \]</div>
<p>где <span class="math notranslate nohighlight">\(\lambda\)</span> – длина шага итерации, определяемая в ходе процедуры <em>line search</em>. Для вычисления матрицы <span class="math notranslate nohighlight">\(\mathbf{B}^{-1}\)</span> на <span class="math notranslate nohighlight">\(\left( k+1 \right)\)</span>-й итерации может быть использована <a class="reference external" href="https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula">формула Шермана-Моррисона</a>:</p>
<div class="math notranslate nohighlight">
\[ \left( \mathbf{B}^{-1} \right)^{k+1} = \left( \mathbf{I} - \left( \frac{ \mathbf{p} \mathbf{y}^\top}{\mathbf{y}^\top \mathbf{p}} \right)^k \right) \left( \mathbf{B}^{-1} \right)^k \left( \mathbf{I} - \left( \frac{\mathbf{y} \mathbf{p}^\top}{\mathbf{y}^\top \mathbf{p}} \right)^k \right) + \left( \frac{\mathbf{p} \mathbf{p}^\top}{\mathbf{y}^\top \mathbf{p}} \right)^k. \]</div>
<!-- TODO: Как это выражение получилось? -->
<p>Метод <em>BFGS</em> может быть использован и в случае выбора логарифмов констант фазового равновесия в качестве основных переменных. В этом случае на <span class="math notranslate nohighlight">\(\left( k+1 \right)\)</span>-й итерации:</p>
<div class="math notranslate nohighlight">
\[ \ln \mathbf{k}^{k+1} = \ln \mathbf{k}^k - \lambda \mathbf{U} \mathbf{B}^{-1} \mathbf{g}. \]</div>
<p>При этом на каждой итерации необходимо решать уравнение (систему уравнений) Речфорда-Райса для расчета мольных долей фаз и мольных долей компонентов в фазах.</p>
<!-- TODO: Описать алгоритм BFGS для расчета равновесного состояния. -->
<!-- TODO: Показать, как для представленного выше примера работает метод BFGS. -->
<p>Стоит отметить, что квази-ньютоновские методы имеют плохую сходимость для плохообусловленных проблем, хотя и не настолько плохую, как метод градиентного спуска [<a class="reference external" href="http://doi.org/10.26153/tsw/2663">Alger, 2019</a>], модификацией которого является метод последовательных подстановок.</p>
<!-- TODO: Показать, как изменяется количество итераций метода BFGS от давления. -->
<p>Таким образом, в рамках данного подраздела были подробно рассмотрены различные алгоритмы расчета равновесного состояния для известных давления, температуры и компонентного состава, а также их реализации. Следующий подраздел будет посвящен нахождению равновесного состояния для известных объема, температуры и компонентного состава.</p>
</section>
<section id="vt">
<span id="pvt-esc-equilibrium-vt"></span><h2>VT-термодинамика<a class="headerlink" href="#vt" title="Link to this heading">#</a></h2>
<!-- TODO: Показать, как учитывать условие электронейтральности при расчете равновесного состояния. -->
<!-- TODO: Показать пример расчета равновесного состояния с учетом распределения ионов в полярных фазах. -->
<p>Стоит отметить, что в данном разделе основное внимание уделялось алгоритмам нахождения равновесного состояния для различных условий. Однако оптимизация времени, затрачиваемого на работу того или иного алгоритма, зависит не только от самого алгоритма, но и от его реализации: работы с памятью, распараллеливания, векторизации вычислений. Подробнее это было рассмотрено авторами работы [<a class="reference external" href="https://doi.org/10.2118/163583-MS">Haugen and Beckner, 2013</a>].</p>
<p>Данный раздел, был посвящен нахождению равновесного состояния для различных формулировок. В следующих разделах будут рассмотрены алгоритмы нахождения предельных состояний, характерных для многокомпонентных систем. В том числе речь пойдет про поиск линий насыщения, конденсации, а также про определение критического состояния системы, являющегося пределом фазового равновесия.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./1-PVT\3-SEC"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="SEC-4-RR-NP.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Уравнение Речфорда-Райса для многофазных систем</p>
      </div>
    </a>
    <a class="right-next"
       href="SEC-6-Saturation.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Определение насыщенного состояния системы</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pt">PT-термодинамика</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#vt">VT-термодинамика</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Daniel Skorov
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022 – 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>