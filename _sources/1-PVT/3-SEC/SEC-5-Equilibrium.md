---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 3.0.1
    jupytext_version: 1.16.3
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

(pvt-esc-equilibrium)=
# Определение равновесного состояния системы

В предыдущих разделах были представлены особенности проверки [стабильности фазового состояния системы](SEC-1-Stability.md), а также получено [уравнение Речфорда-Райса](SEC-2-RR.md) и рассмотрены численные методы его решения для [двухфазной](SEC-3-RR-2P.md) и [многофазной](SEC-4-RR-NP.md) систем. Данный раздел посвящен расчету равновесного фазового состояния, проводимому в том случае, если по результатам анализа стабильности текущее фазовое состояние оказалось нестабильным. Как и в случае анализа стабильности, расчет равновесного состояния также имеет различные формулировки ([PT-термодинамика](#pvt-esc-equilibrium-pt), [VT-термодинамика](#pvt-esc-equilibrium-vt)).

(pvt-esc-equilibrium-pt)=
## PT-термодинамика

Задача поиска равновесного состояния многокомпонентной ($N_c$ – количество компонентов) многофазной ($N_p$ – количество фаз) системы для фиксированных давления $P$, температуры $T$, количеств вещества компонентов в системе $n_i, \; i = 1 \, \ldots \, N_c$ достаточно хорошо изучена и проработана. [Ранее](../1-TD/TD-14-PhaseEquilibrium.md) было показано, что равновесное состояние характеризуется минимумом энергии Гиббса. При этом, необходимым условием равновесного состояния является равенство химических потенциалов (или летучестей) соответствующих компонентов в фазах. Это условие определяет положение стационарных точек функции энергии Гиббса, [называемых](SEC-1-Stability.md) стационарными состояниями системы.

В результате решения задачи поиска равновесного состояния системы требуется определить количества вещества компонентов в фазах, всего $N_c \times \left( N_p - 1 \right)$ неизвестных с учетом ограничения $\sum_{j=1}^{N_p} n_i^j = n_i$, соответствующих положению минимума функции энергии Гиббса. Существует два основных направления решения данной задачи. Первое направление включает широкую группу подходов, основанных на ***методе последовательных подстановок*** *(successive (direct) substitution method)*. Данный метод, по сути, эквивалентен [методу градиентного спуска](https://en.wikipedia.org/wiki/Gradient_descent) с длиной шага, равной единице, с точки зрения минимизации энергии Гиббса. Преимуществом данного метода является его относительная простота, поскольку нет необходимости в расчете многомерных матриц и вторых частных производных функции энергии Гиббса. Недостатком данного метода является необходимость сравнительно большого количества итераций для нахождения решения, при этом, данный метод может сходиться к стационарным точкам функции. Метод последовательных подстановок подробно представлен в работах \[[Michelsen, 1982b](https://doi.org/10.1016/0378-3812(82)85002-4); [Heidemann, 1983](https://doi.org/10.1016/0378-3812(83)80115-0); [Mehra et al, 1983](https://doi.org/10.1002/cjce.5450610414)\]. Другим направлением решения задачи поиска равновесного состояния является совокупность [методов глобальной оптимизации](https://en.wikipedia.org/wiki/Global_optimization) функции энергии Гиббса, частично представленная в работах \[[Nichita et al, 2002](https://doi.org/10.1016/S0098-1354(02)00144-8); [Nichita et al, 2004](https://doi.org/10.2118/04-05-TN2), [Petitfrere and Nichita, 2014](https://doi.org/10.1016/j.fluid.2013.08.039)\]. В рамках данного курса подробно остановимся на методах определения равновесного состояния, относящихся к первому направлению.

Отношение мольной доли $i$-го компонента в $j$-й фазе, где $j = 1 \, \ldots \, N_p-1$, к мольной доли этого же компонента в референсной фазе (поскольку референсной фазой может быть любая, то здесь и далее под референсной фазой понимается фаза с индексом $N_p$) называется *константой фазового равновесия*:

$$ K_i^j = \frac{y_i^j}{y_i^{N_p}}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c. $$

Данный параметр также использовался при выводе [уравнения Речфорда-Райса](SEC-2-RR.md).

Ключевой особенностью метода последовательных подстановок является итеративное обновление констант фазового равновесия в процессе поиска равновесного состояния, осуществляемое с использованием следующего выражения:

$$ {K_i^j}_{k+1} = {K_i^j}_{k} \frac{f_i \left( P, \, T, \, y_i^{N_p} \right)}{f_i \left( P, \, T, \, y_i^j \right)}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c. $$

где ${K_i^j}_{k+1}$ – константа фазового равновесия $i$-го компонента в $j$-й фазе на $\left( k+1 \right)$-й итерации, ${K_i^j}_{k}$ – константа фазового равновесия $i$-го компонента в $j$-й фазе на $k$-й итерации, $f_i \left( P, \, T, \, y_i^j \right)$ – летучесть $i$-го компонента в $j$-й фазе, $f_i \left( P, \, T, \, y_i^{N_p} \right)$ – летучесть $i$-го компонента в референсной фазе.

Преобразуем данное выражение к следующему виду:

$$ \begin{align}
\ln {K_i^j}_{k+1} &= \ln {K_i^j}_{k} + \ln f_i  \left( P, \, T, \, y_i^{N_p} \right) - \ln f_i \left( P, \, T, \, y_i^j \right), \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c, \\
\Delta \ln {K_i^j}_{k} &= \ln f_i  \left( P, \, T, \, y_i^j \right) - \ln f_i \left( P, \, T, \, y_i^{N_p} \right), \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c, \\
\Delta \ln {K_i^j}_{k} &= \ln {K_i^j}_{k} + \ln \varphi_i \left( P, \, T, \, y_i^j \right) - \ln \varphi_i  \left( P, \, T, \, y_i^{N_p} \right), \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c.
\end{align} $$

Тогда итеративное обновление констант фазового равновесия в методе последовательных подстановок записывается в следующем виде:

$$ \ln {K_i^j}_{k+1} = \ln {K_i^j}_{k} - \Delta \ln {K_i^j}_{k}, \; j = 1 \, \ldots \, N_p - 1, \; i = 1 \, \ldots \, N_c. $$

В свою очередь, метод градиентного спуска для минимизации функции энергии Гиббса с выбранными в качестве основных переменных логарифмами констант фазового равновесия:

$$ \begin{align}
\ln {K_i^j}_{k+1}
&= \ln {K_i^j}_{k} - \lambda \left( \frac{\partial \bar{G}}{\partial \ln K_i^j} \right)_{P, \, T, \, K_l^m \neq K_i^j} \\
&= \ln {K_i^j}_{k} - \lambda \sum_{l=1}^{N_c} \sum_{m=1}^{N_p-1} \left( \frac{\partial \bar{G}}{\partial n_l^m} \right)_{P, \, T, \, n_i^j \neq n_l^m} \left( \frac{\partial n_l^m}{\partial \ln K_i^j} \right)_{P, \, T, \, K_l^m \neq K_i^j} \\
&= \ln {K_i^j}_{k} - \lambda \sum_{l=1}^{N_c} \sum_{m=1}^{N_p-1} \left( \ln f_l \left( P, \, T, \, y_l^m \right) - \ln f_l \left( P, \, T, \, y_l^{N_p} \right) \right) U_{lmij}^{-1}.
\end{align} $$

В представленном выражении параметр $\lambda$ характеризует длину шага, а $\bar{G} = G / \left(RT\right)$ – приведенная энергия Гиббса системы. При преобразовании данного выражения учитывалось [правило дифференцирования сложной функции от нескольких переменных](https://en.wikipedia.org/wiki/Chain_rule#General_rule:_Vector-valued_functions_with_multiple_inputs). Если принять

$$ \lambda = 1, $$

$$ U_{lmij}^{-1} = \delta_{lmij} = \begin{cases} 1, \; l = i, \; m = j, \; i = 1 \, \ldots \, N_c, \; j = 1 \, \ldots \, N_p - 1, \\ 0, \; \mathrm{otherwise}, \end{cases} $$

тогда метод последовательных подстановок будет эквивалентен методу градиентного спуска для минимизации функции энергии Гиббса. Таким образом, метод последовательных подстановок является своеобразным упрощением метода градиентного спуска для минимизации функции энергии Гиббса.

<!-- TODO: добавить анализ матрицы U_{lmij}. См. 10.1002/cjce.5450610414, 10.1002/aic.690330606, 10.1016/j.fluid.2014.11.017 -->

Рассмотрим алгоритм метода последовательных подстановок.

```{eval-rst}
.. role:: comment
    :class: comment
```

```{admonition} Алгоритм. Метод последовательных подстановок для определения равновесного состояния
:class: algorithm

**Дано:** Вектор компонентного состава исследуемой системы $\mathbf{z} \in {\rm I\!R}^{N_c}$; термобарические условия $P$ и $T$; количество вещества в системе $n=1 \, моль$; необходимые свойства компонентов для нахождения коэффициентов летучести компонентов с использованием уравнения состояния; количество фаз в системе $N_p$; набор (тензор) начальных приближений констант фазового равновесия $\mathbf{K}_0 \in {\rm I\!R}^{N \times \left( N_p - 1 \right) \times N_c}$; максимальное число итераций $N_{iter}$; точность $\epsilon$; длина шага $\lambda = 1$.

**Определить:** Компонентные составы фаз $\mathbf{Y} \in {\rm I\!R}^{ \left( N_p - 1 \right) \times N_c}$ и мольные доли фаз $\mathbf{F} \in {\rm I\!R}^{N_p-1}$ в системе, соответствующие равновесному состоянию.

**Псевдокод:**  
**def** $\phi \left( \mathbf{Y} \in {\rm I\!R}^{\left( N_p - 1 \right) \times N_c}, \, \ldots \right) \rightarrow \mathbf{\Phi} \in {\rm I\!R}^{\left( N_p - 1 \right) \times N_c}$ {comment}`# Функция для расчета матрицы коэф-тов летучести`  
**def** $R \left( \mathbf{K} \in {\rm I\!R}^{\left( N_p - 1 \right) \times N_c}, \, \mathbf{z} \right) \rightarrow \mathbf{F} \in {\rm I\!R}^{N_p-1}$ {comment}`# Функция для решения уравнения Речфорда-Райса`  
**for** $i := 1$ **to** $N$ **do** {comment}`# Цикл перебора начальных приближений`  
&emsp;$\mathbf{K} := \mathbf{K}_0 \left[ i,:,: \right]$ {comment}`# Матрица начальных приближений констант фазового равновесия`  
&emsp;$\mathbf{F} := R \left( \mathbf{K}, \, \mathbf{z} \right)$ {comment}`# Вектор мольных долей фаз для начального приближения`  
&emsp;$\mathbf{x} := \mathbf{z} \, / \left( \mathbf{F}^\top \left(\mathbf{K} - 1 \right) + 1 \right)$ {comment}`# Компонентный состав референсной фазы`  
&emsp;$\mathbf{Y} := \mathbf{K} \cdot \mathbf{x}$ {comment}`# Матрица компонентных составов нереференсных фаз`  
&emsp;$\mathbf{\Phi} := \phi \left( \mathbf{Y} \right)$ {comment}`# Матрица коэффициентов летучести компонентов в нереференсных фазах`  
&emsp;$\mathbf{\varphi} := \phi \left( \mathbf{x} \right)$ {comment}`# Вектор коэффициентов летучести компонентов в референсной фазе`  
&emsp;$\mathbf{g} := \ln \mathbf{K} + \ln \mathbf{\Phi} - \ln \mathbf{\varphi}$ {comment}`# Матрица невязок`  
&emsp;$k := 1$ {comment}`# Счетчик итераций`  
&emsp;**while** $\lVert \mathbf{g} \rVert_2 > \epsilon$ **and** $k < N_{iter}$ **do** {comment}`# Цикл решения системы нелинейных уравнений`  
&emsp;&emsp;$\mathbf{K} := \mathbf{K} \cdot \exp \left( - \lambda \mathbf{g} \right)$  {comment}`# Обновление матрицы основных переменных`  
&emsp;&emsp;$\mathbf{F} := R \left( \mathbf{K}, \, \mathbf{z} \right)$ {comment}`# Вектор мольных долей фаз`  
&emsp;&emsp;$\mathbf{x} := \mathbf{z} \, / \left( \mathbf{F}^\top \left(\mathbf{K} - 1 \right) + 1 \right)$ {comment}`# Компонентный состав референсной фазы`  
&emsp;&emsp;$\mathbf{Y} := \mathbf{K} \cdot \mathbf{x}$ {comment}`# Матрица компонентных составов нереференсных фаз`  
&emsp;&emsp;$\mathbf{\Phi} := \phi \left( \mathbf{Y} \right)$ {comment}`# Матрица коэффициентов летучести компонентов в нереференсных фазах`  
&emsp;&emsp;$\mathbf{\varphi} := \phi \left( \mathbf{x} \right)$ {comment}`# Вектор коэффициентов летучести компонентов в референсной фазе`  
&emsp;&emsp;$\mathbf{g} := \ln \mathbf{K} + \ln \mathbf{\Phi} - \ln \mathbf{\varphi}$ {comment}`# Матрица невязок`  
&emsp;&emsp;$k := k + 1$ {comment}`# Обновление счетчика итераций`  
&emsp;**end while**  
&emsp;**if** $k < N_{iter}$ **then**  
&emsp;&emsp;**exit for**  
&emsp;**end if**  
**end for**  
```

Таким образом, метод последовательных подстановок характеризуется наличием двух `while`-циклов: внутренний цикл используется для решения уравнения Речфорда-Райса при фиксированных константах фазового равновесия, внешний цикл – для обновления констант фазового равновесия, исходя из необходимого условия равновесия.

В качестве начальных приближений констант фазового равновесия для расчета равновесного состояния можно использовать тот же набор начальных приближений, что и для [проверки стабильности системы](SEC-1-Stability.md). Кроме того, в качестве начального приближения к определению равновесного состояния можно использовать результаты анализа стабильности, одним из которых является вектор $Y_i, \; i = 1 \, \ldots \, N_c$, интерепретируемый как вектор количеств вещества компонентов в системе. Тогда вектор

$$ y_i = \frac{Y_i}{\sum_{j=1}^{N_c} Y_j}, \; i = 1 \, \ldots \, N_c, $$

представляет собой вектор мольных долей компонентов в системе. Следовательно, набор начальных приближений для расчета равновесного состояния:

$$ \mathbf{K}_0 = \left\{ y_i \, / \, z_i, \; z_i  \, / \, y_i, \; i = 1 \, \ldots \, N_c \right\}. $$

После определения равновесного состояния для $N_p$-фазной постановки задачи выполняется анализ стабильности системы. Если анализ стабильности показывает, что $N_p$-фазный компонентный состав не является стабильным, то выполняется поиск равновесного состояния для $\left( N_p+1 \right)$-фазной постановки.

Рассмотрим применения метода последовательных подстановок для нахождения равновесного состояния. В данном подразделе будет использоваться [уравнение состояние Пенга-Робинсона](../2-EOS/EOS-2-SRK-PR.md) и его [реализация](https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/eos.py). Кроме того, для проверки стабильности системы будет применяться метод QNSS, алгоритм которого был рассмотрен [ранее](SEC-1-Stability.md), реализованный [здесь](https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/stability.py). Также на каждой итерации метода последовательных подстановок необходимо решать [уравнение Речфорда-Райса](SEC-2-RR.md). Для решения уравнения в двухфазной постановке будет использоваться [реализация](https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/rr.py) [метода FGH](SEC-3-RR-2P.md), для решения системы уравнений Речфорда-Райса – модифицированный метод \[[Okuno et al, 2010](https://doi.org/10.2118/117752-PA)\], реализация которого представлена [здесь](https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/rr.py).

```{code-cell} python
import sys
sys.path.append('../../_src/')
from eos import pr78
from stability import stabilityPT
from rr import solve2p_FGH, solveNp
```

```{admonition} Пример
:class: exercise
Пусть имеется $1 \; моль$ смеси из метана и диоксида углерода при температуре $10 \; ^{\circ} C$ и давлении $6 \; МПа$ с мольной долей метана $0.1$. Необходимо определить равновесное состояние системы.
```

Зададим исходные термобарические условия и компонентный состав.

```{code-cell} python
import numpy as np
P = np.float64(6e6) # Pressure [Pa]
T = np.float64(10. + 273.15) # Temperature [K]
yi = np.array([.9, .1]) # Mole fractions [fr.]
```

Также зададим максимальное число итераций $N_{iter}$, точность решения системы нелинейных уравнений $\epsilon$:

```{code-cell} python
Niter = 50 # Number of iterations
eps = np.float64(1e-6) # Tolerance
```

Зададим свойства компонентов, необходимые для уравнения состояния Пенга-Робинсона, и выполним инициализацию класса.

```{code-cell} python
Pci = np.array([7.37646, 4.600155]) * 1e6 # Critical pressures [Pa]
Tci = np.array([304.2, 190.6]) # Critical temperatures [K]
wi = np.array([.225, .008]) # Acentric factors
mwi = np.array([0.04401, 0.016043]) # Molar mass [kg/gmole]
vsi = np.array([0., 0.]) # Volume shift parameters
dij = np.array([.025]) # Binary interaction parameters
pr = pr78(Pci, Tci, wi, mwi, vsi, dij)
```

Проиницилизируем класс для проведения теста стабильности и выполним проверку стабильности однофазного состояния:

```{code-cell} python
stab = stabilityPT(pr, method='qnss')
stabres = stab.run(P, T, yi)
stabres
```

В результате проверки стабильности (путем вызова метода `run`) однофазное состояние системы оказалось нестабильным. В [разделе](SEC-1-Stability.md), посвященном тесту стабильности, применение метода QNSS для данного примера было представлено подробнее. Также был получен набор начальных приближений для проведения расчета равновесного состояния (принцип получения начальных приближений также подробнее был представлен в [разделе](SEC-1-Stability.md), посвященном проверке стабильности некоторого состояния системы):

```{code-cell} python
stabres.kvji
```

Создадим функцию, которая будет принимать на вход кортеж из результатов предыдущей итерации, точность и максимальное число итераций, и возвращать необходимость расчета следующей итерации цикла решения системы нелинейных уравнений. Проиницилизируем данную функцию.

```{code-cell} python
import numpy.typing as npt
from functools import partial

def condit(
    carry: tuple[int, npt.NDArray[np.float64], np.float64, npt.NDArray[np.float64]],
    tol: np.float64,
    Niter: int,
) -> bool:
    k, kvi, _, gi = carry
    return (k < Niter) & (np.linalg.norm(gi) > tol)

pcondit = partial(condit, tol=eps, Niter=Niter)
```

Также создадим функцию, которая будет принимать на вход результаты предыдущей итерации в виде кортежа, и рассчитывать результаты для новой итерации.

```{code-cell} python
from typing import Callable

def update_ssi_2p(
    carry: tuple[int, npt.NDArray[np.float64], np.float64, npt.NDArray[np.float64]],
    yi: npt.NDArray[np.float64],
    plnphi: Callable[[npt.NDArray[np.float64]], npt.NDArray[np.float64]],
) -> tuple[int, npt.NDArray[np.float64], np.float64, npt.NDArray[np.float64]]:
    k, kvi_k, _, gi_k = carry
    kvi_kp1 = kvi_k * np.exp(-gi_k)
    F1 = solve2p_FGH(kvi_kp1, yi)
    y2i = yi / (F1 * (kvi_kp1 - 1.) + 1.)
    y1i = y2i * kvi_kp1
    lnphi2i = plnphi(yi=y2i)
    lnphi1i = plnphi(yi=y1i)
    gi_kp1 = np.log(kvi_kp1) + lnphi1i - lnphi2i
    return k + 1, kvi_kp1, F1, gi_kp1

pupdate_ssi_2p = partial(update_ssi_2p, yi=yi, plnphi=partial(pr.getPT_lnphii, P=P, T=T))
```

Найдем равновесное состояние с использованием метода последовательных подстановок:

```{code-cell} python
for i, kvi in enumerate(stabres.kvji):
    F1 = solve2p_FGH(kvi, yi)
    y2i = yi / (F1 * (kvi - 1.) + 1.)
    y1i = y2i * kvi
    lnphi2i = pr.getPT_lnphii(P, T, y2i)
    lnphi1i = pr.getPT_lnphii(P, T, y1i)
    gi = np.log(kvi) + lnphi1i - lnphi2i
    carry = (1, kvi, F1, gi)
    while pcondit(carry):
        carry = pupdate_ssi_2p(carry)
    k, kvi, F1, gi = carry
    if k < Niter:
        y2i = yi / (F1 * (kvi - 1.) + 1.)
        y1i = y2i * kvi
        print(f'For the initial guess #{i}:\n'
              f'\ttolerance of equations: {np.linalg.norm(gi)}\n'
              f'\tnumber of iterations: {k}\n'
              f'\tphase compositions:\n\t\t{y1i}\n\t\t{y2i}\n'
              f'\tphase mole fractions: {F1}, {1.-F1}')
        break
```

Выполним проверку стабильности найденного решения:

```{code-cell} python
stab.run(P, T, y1i)
```

Тест стабильности показал, что найденное решение соответствует равновесному состоянию. Проиллюстрируем данный пример графически. Для этого построим зависимость функции энергии Гиббса для первой фазы от компонентного состава и проведем касательную в точке с найденным равновесным составом этой фазы. Значения функции энергии Гиббса:

```{code-cell} python
yj1 = np.linspace(1e-4, 0.9999, 100, endpoint=True)
yji = np.vstack([yj1, 1. - yj1]).T
lnphiji, Zj = pr.getPT_lnphiji_Zj(P, T, yji)
lnfji = lnphiji + np.log(P * yji)
Gj = np.sum(yji * lnfji, axis=1)
```

Уравнение касательной:

```{code-cell} python
lnfi = pr.getPT_lnfi(P, T, y1i)
Lj = np.sum(yji * lnfi, axis=1)
```

Построение графиков функции энергии Гиббса и касательной:

```{code-cell} python
from matplotlib import pyplot as plt

fig1, ax1 = plt.subplots(1, 1, figsize=(6., 4.), tight_layout=True)
ax1.plot(yj1, Gj, lw=2., c='teal', zorder=2, label='Приведенная энергия Гиббса')
ax1.plot(yj1, Lj, lw=2., c='orchid', zorder=2, label='Касательная')
ax1.set_xlim(0., 1.)
ax1.set_xlabel('Количество вещества диоксида углерода в системе, моль')
ax1.set_ylabel('Приведенная энергия Гиббса')
ax1.grid(zorder=1)

axins1 = ax1.inset_axes([0.04, 0.05, 0.5, 0.89], xlim=(0.65, 0.975), ylim=(14.5, 15.1),
                        xticklabels=[], yticklabels=[])
ax1.indicate_inset_zoom(axins1, edgecolor='black')
axins1.plot(yj1, Gj, lw=2., c='teal', zorder=2, label='Приведенная энергия Гиббса')
axins1.plot(yj1, Lj, lw=2., c='orchid', zorder=2, label='Касательная')
axins1.plot(y1i[0], y1i.dot(lnfi), 'o', lw=0., mfc='blue', mec='blue', ms=5., zorder=3)
axins1.plot(y2i[0], y2i.dot(lnfi), 'o', lw=0., mfc='green', mec='green', ms=5., zorder=3)
axins1.plot([y1i[0], y1i[0]], [0., y1i.dot(lnfi)], '--', lw=1., c='blue', zorder=2)
axins1.plot([y2i[0], y2i[0]], [0., y2i.dot(lnfi)], '--', lw=1., c='green', zorder=2)
axins1.text(0.8, 14.55, '$y_{CO_2} = 0.818$', fontsize=8, color='blue', rotation='vertical')
axins1.text(0.9, 14.55, '$y_{CO_2} = 0.918$', fontsize=8, color='green', rotation='vertical')
axins1.set_xticks([0.8])
axins1.set_yticks([14.6, 14.8, 15.0])
axins1.legend(loc=2, fontsize=8)
axins1.grid(zorder=1)
```

Из данного графика следует, что касательная, проведенная к функции энергии Гиббса в точке с компонентным составом первой фазы, не имеет пересечений с самой функцией, что подтверждает сделанный вывод о равновесности найденного состояния. Кроме того, можно отметить, что касательная имеет две точки касания, абсциссы которых соответствуют равновесным компонентным составам фаз, то есть функция энергии Гиббса имеет одинаковую касательную для каждого из компонентных составов, определяющих стационарное состояние. Это следует из равенства летучестей соответствующих компонентов в фазах, а полное доказательство данного утверждения было рассмотрено [ранее](SEC-1-Stability.md). Стоит также отметить, что две точки, показанные на графике, соответствующие двухфазному равновесному состоянию, называются ***бинодальными точками***.

Таким образом, на примере, представленном выше, было рассмотрено применение метода последовательных подстановок для расчета равновесного состояния в двухфазной постановке. Однако этот метод может применяться и для многофазного случая. Рассмотрим следующий пример.

```{admonition} Пример
:class: exercise
Пусть имеется $1 \; моль$ смеси из метана, гексана и воды при температуре $20 \; ^{\circ} C$ и давлении $1 \; атм$ с мольными долями компонентов $0.1, \, 0.6, \, 0.3$ соответственно. Необходимо определить равновесное состояние системы.
```

Зададим исходные термобарические условия и компонентный состав.

```{code-cell} python
P = np.float64(101325.) # Pressure [Pa]
T = np.float64(20. + 273.15) # Temperature [K]
yi = np.array([.1, .6, .3]) # Mole fractions [fr.]
```

Зададим свойства компонентов, необходимые для уравнения состояния Пенга-Робинсона, и выполним инициализацию класса.

```{code-cell} python
Pci = np.array([4.600155, 3.2890095, 22.04832]) * 1e6 # Critical pressures [Pa]
Tci = np.array([190.6, 507.5, 647.3]) # Critical temperatures [K]
wi = np.array([.008, .27504, .344]) # Acentric factors
mwi = np.array([0.016043, 0.086, 0.018015]) # Molar mass [kg/gmole]
vsi = np.array([0., 0., 0.]) # Volume shift parameters
dij = np.array([.0253, 0.4907, 0.48]) # Binary interaction parameters
pr = pr78(Pci, Tci, wi, mwi, vsi, dij)
```

Проиницилизируем класс для проведения теста стабильности и выполним проверку стабильности однофазного состояния:

```{code-cell} python
stab = stabilityPT(pr, method='qnss', level=1) # level=1 means more cases of initial k-values
stabres = stab.run(P, T, yi)
stabres
```

Однофазное состояние оказалось нестабильным, выполним расчет двухфазного равновесного состояния. Для этого сначала проинициализируем функцию `update_ssi_2p` для рассматриваемого примера. Поскольку точность расчета и максимальное количество итераций не изменилось, то будем использовать функцию `pcondit` из предыдущего примера:

```{code-cell} python
pupdate_ssi_2p = partial(update_ssi_2p, yi=yi, plnphi=partial(pr.getPT_lnphii, P=P, T=T))
```

Перебирая различные начальные приближения констант фазового равновесия, полученные после проверки стабильности однофазного состояния, выполним расчет равновесного состояния в двухфазной постановке:

```{code-cell} python
for i, kvi in enumerate(stabres.kvji):
    F1 = solve2p_FGH(kvi, yi)
    y2i = yi / (F1 * (kvi - 1.) + 1.)
    y1i = y2i * kvi
    lnphi2i = pr.getPT_lnphii(P, T, y2i)
    lnphi1i = pr.getPT_lnphii(P, T, y1i)
    gi = np.log(kvi) + lnphi1i - lnphi2i
    carry = (1, kvi, F1, gi)
    while pcondit(carry):
        carry = pupdate_ssi_2p(carry)
    k, kvi, F1, gi = carry
    if k < Niter:
        y2i = yi / (F1 * (kvi - 1.) + 1.)
        y1i = y2i * kvi
        print(f'For the initial guess #{i}:\n'
              f'\ttolerance of equations: {np.linalg.norm(gi)}\n'
              f'\tnumber of iterations: {k}\n'
              f'\tphase compositions:\n\t\t{y1i}\n\t\t{y2i}\n'
              f'\tphase mole fractions: {F1}, {1.-F1}')
        break
```

Метод последовательных подстановок нашел состояние, характеризующееся равенством летучестей соответствующих компонентов в фазах, за пять итераций. Проверим, является ли двухфазное состояние стабильным. Для этого проведем тест стабильности для одной из фаз:

```{code-cell} python
stabres = stab.run(P, T, y2i)
stabres
```

По результатам проверки стабильности двухфазное равновесное состояние оказалось нестабильным, следовательно, необходимо выполнить расчет для трехфазного равновесного состояния. Остановимся подробнее на задании начального приближения для многофазного расчета равновесного состояния. Результатом двухфазного расчета равновесного состояния является некоторое состояние системы, характеризующиеся равенством летучестей соответствующих компонентов, компонентными составами фаз $y^1_i$ и $y^2_i$, мольными долями фаз $F_1$ и $F_2$, а также константами фазого равновесия $K_i^{12} = y^1_i \, / \, y^2_i$. Затем был проведен тест стабильности компонентного состава $y^2_i$, показавший его нестабильность, в ходе которого удалось подобрать некоторую мнимую фазу *(trial phase)* с компонентным составом $x_i$ и константами фазового равновесия $K_i^{t2} = x_i \, / \, y^2_i$, также находящуюся в термодинамическом равновесии. Таким образом, набор констант фазового равновесия $\mathbf{K} = \left\{ K_i^{12}, \, K_i^{t2} \right\}$ является хорошим начальным приближением для расчета трехфазного равновесного состояния, согласно \[[Li and Firoozabadi, 2012](https://doi.org/10.1016/j.fluid.2012.06.021)\]. При этом, начальное приближение необходимо и для [алгоритма](SEC-4-RR-NP.md) решения системы уравнений Речфорда-Райса, в качестве которого может выступить вектор $\mathbf{F} = \left( F_1, \, 0 \right)^\top$, поскольку мнимая фаза характеризуется пренебрежимо малой мольной долей.

С учетом изложенного выше, сформируем матрицу констант фазового равновесия для первой итерации расчета трехфазного равновесного состояния:

```{code-cell} python
kvji = np.vstack([kvi, stabres.kvji[0]])
kvji
```

Определим мольные доли фаз, соответствующие этому начальному приближению:

```{code-cell} python
Fj = solveNp(kvji, yi, np.array([F1, 0.]))
Fj
```

Рассчитаем компонентные составы фаз:

```{code-cell} python
xi = yi / (Fj.dot(kvji - 1.) + 1.)
yji = xi * kvji
```
Выполним расчет коэффициентов летучестей для каждого компонента в каждой из фаз. Для этого воспользуемся методом `get_lnphiji_Zj` класса `pr`:

```{code-cell} python
lnphiji, Zj = pr.getPT_lnphiji_Zj(P, T, np.vstack([yji, xi]))
```

Рассчитаем матрицу невязок:

```{code-cell} python
gji = np.log(kvji) + lnphiji[:-1] - lnphiji[-1]
```

Создадим функцию, которая будет получать на вход результаты предыдущей итерации и возвращать результаты следующей итерации метода последовательных подстановок:

```{code-cell} python
def update_ssi_Np(
    carry: tuple[int, npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]],
    yi: npt.NDArray[np.float64],
    plnphi: Callable[[npt.NDArray[np.float64]], tuple[npt.NDArray[np.float64], npt.NDArray[np.float64]]],
) -> tuple[int, npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    k, kvji_k, Fj0, gji_k = carry
    kvji_kp1 = kvji_k * np.exp(-gji_k)
    Fj = solveNp(kvji_kp1, yi, Fj0)
    xi = yi / (Fj.dot(kvji_kp1 - 1.) + 1.)
    yji = xi * kvji_kp1
    lnphiji, Zj = plnphi(yji=np.vstack([yji, xi]))
    gji_kp1 = np.log(kvji_kp1) + lnphiji[:-1] - lnphiji[-1]
    return k + 1, kvji_kp1, Fj, gji_kp1

pupdate_ssi_Np = partial(update_ssi_Np, yi=yi, plnphi=partial(pr.getPT_lnphiji_Zj, P=P, T=T))
```

В цикле `while` выполним расчет трехфазного равновесного состояния:

```{code-cell} python
carry = (1, kvji, Fj, gji)

while pcondit(carry):
    carry = pupdate_ssi_Np(carry)

k, kvji, Fj, gji = carry

xi = yi / (Fj.dot(kvji - 1.) + 1.)
yji = np.vstack([xi * kvji, xi])
Fj = np.hstack([Fj, 1. - Fj.sum()])

print(f'Tolerance of equations: {np.linalg.norm(gji)}\n'
      f'Number of iterations: {k}\n'
      f'Phase compositions:\n{yji}\n'
      f'Phase mole fractions: {Fj}')
```

Выполним проверку стабильности компонентного состава одной из фаз:

```{code-cell} python
stab.run(P, T, yji[1])
```

Таким образом, на представленных примерах было продемонстрировано применение метода последовательных подстановок для нахождения двух- и трехфазного равновесного состояния. Как уже было отмечено ранее, недостатком этого метода является сравнительно большое количество итераций и медленная сходимость для случаев вблизи [линии насыщения](SEC-6-Saturation.md) или вблизи [критической точки](SEC-7-Criticality.md). Для ускорения могут применяться различные модификации данного метода, полученные авторами работ \[[Mehra et al, 1983](https://doi.org/10.1002/cjce.5450610414); [Nghiem and Li, 1984](https://doi.org/10.1016/0378-3812(84)80013-8)\]. Реализация метода *QNSS* представлена [здесь](https://github.com/DanielSkorov/ReservoirSimulation/blob/main/_src/flash.py).

Особенностью данных методов является введение коэффициента *длины шага итерации*, обозначенного в представленном выше алгоритме, как $\lambda$, и его расчет с использованием следующего выражения:

$$ \lambda_{k} = \lambda_{k-1} \frac{\mathbf{g}_{k-1}^\top \mathbf{g}_{k-1}}{\mathbf{g}_{k-1}^\top \left( \mathbf{g}_{k-1} - \mathbf{g}_k \right)}, $$

а итерация записывается следующим образом:

$$ \ln \mathbf{k}_{k+1} = \ln \mathbf{k}_k - \lambda_k \mathbf{g}_k. $$

Стоит отметить, что в обоих случаях предполагается выполнение первой итерации с использованием метода последовательных подстановок, то есть $\lambda_0 = 1$. Оба метода могут быть распространены и на многофазные системы. В этом случае, например, вектор $\mathbf{g}$ записывается следующим образом:

$$ \mathbf{g} = \begin{bmatrix} \ln k_1^{1N_p} + \ln \phi_1^1 - \ln \phi_1^{N_p} \\ \ln k_2^{1N_p} + \ln \phi_2^1 - \ln \phi_2^{N_p} \\ \vdots \\ \ln k_{N_c}^{1N_p} + \ln \phi_{N_c}^1 - \ln \phi_{N_c}^{N_p} \\ \ln k_1^{2N_p} + \ln \phi_1^2 - \ln \phi_1^{N_p} \\ \ln k_2^{2N_p} + \ln \phi_2^2 - \ln \phi_2^{N_p} \\ \vdots \\ \ln k_{N_c}^{2N_p} + \ln \phi_{N_c}^2 - \ln \phi_{N_c}^{N_p} \\ \vdots \\ \ln k_{N_c}^{N_p-1,N_p} + \ln \phi_{N_c}^{N_p-1} - \ln \phi_{N_c}^{N_p} \end{bmatrix}. $$

Аналогично записывается вектор основных переменных. С другой стороны, поскольку метод последовательных подстановок является своеобразным упрощением метода градиентного спуска при рассмотрении задачи с точки зрения минимизации энергии Гиббса, то очевидным вариантом ускорения является применение метода Ньютона, требующего нахождение вторых частных производных функции энергии Гиббса по основным переменным. В качестве вектора основных переменных может выступать вектор количеств вещества компонентов в $N_p-1$ фазах.

Рассмотрим формулировку метода Ньютона для минимизации энергии Гиббса в двухфазной постановке. В качестве вектора основных переменных выберем вектор количеств вещества компонентов в жидкой фазе $n_i^L, \, i = 1 \, \ldots \, N_c$. Элемент вектора количеств вещества компонентов в газовой фазе обозначим $n_i^V, \, i = 1 \, \ldots \, N_c$. При этом, количество вещества компонента в газовой фазе выражается через количество вещества компонента в системе $n_i, \, i = 1 \, \ldots \, N_c,$ и количество вещества компонента в жидкой фазе следующим образом:

$$ n_i^V = n_i - n_i^L, \; i = 1 \, \ldots \, N_c. $$

Количество вещества жидкой и газовой фаз можно получить через количество вещества $i$-го компонента:

$$ n^L = \sum_{i = 1}^{N_c} n_i^L, \; n^V = \sum_{i = 1}^{N_c} n_i^V. $$

Для метода Ньютона необходимо получение аналитических выражений вектора градиента энергии Гиббса и матрицы гессиана. Выражение для элемента вектора градиента приведенной (безразмерной) энергии Гиббса было рассмотрено [ранее](SEC-1-Stability.md):

$$ g_i = \ln f_i^L - \ln f_i^V, \; i = 1 \, \ldots \, N_c. $$

Выразим летучесть $i$-го компонента в $j$-й фазе через коэффициент летучести и его количество вещества:

$$ \ln f_i^j = \ln \varphi_i^j y_i^j P = \ln \varphi_i^j \frac{n_i^j}{n^j} P = \ln \varphi_i^j + \ln n_i^j - \ln n^j + \ln P, \; i = 1 \, \ldots \, N_c, \; j = \left\{L, \, V \right\}. $$

Тогда элемент вектора градиента:

$$ g_i = \ln \varphi_i^L + \ln n_i^L - \ln n^L - \left( \ln \varphi_i^V + \ln n_i^V - \ln n^V \right), \; i = 1 \, \ldots \, N_c. $$

Получим выражение для элемента матрицы гессиана:

$$ \begin{alignat}{1}
H_{il}
&= && \frac{\partial g_i}{\partial n_l^L} \\
&= && \frac{\partial \ln \varphi_i^L}{\partial n_l^L} + \frac{\partial \ln n_i^L}{\partial n_l^L} - \frac{\partial \ln n^L}{\partial n_l^L} - \left( \frac{\partial \ln \varphi_i^V}{\partial n_l^V} \frac{\partial n_l^V}{\partial n_l^L} + \frac{\ln n_i^V}{\partial n_l^V} \frac{\partial n_l^V}{\partial n_l^L} - \frac{\partial \ln n^V}{\partial n_l^V} \frac{\partial n_l^V}{\partial n_l^L} \right), \\
&&& i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c.
\end{alignat} $$

Упростим некоторые слагаемые. Частная производная логарифма количества вещества $i$-го компонента в $L$-й фазе по количесту вещества $l$-го компонента в этой же фазе:

$$ \frac{\partial \ln n_i^L}{\partial n_l^L} = \frac{1}{n_i^L} \frac{\partial n_i^L}{\partial n_l^L} = \frac{1}{n_i^L} \delta_{il}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c, $$

где $\delta_{il}, \, i = 1 \, \ldots \, N_c, \, l = 1 \, \ldots \, N_c,$ представляет собой элемент [единичной матрицы](https://en.wikipedia.org/wiki/Identity_matrix) – [дельта Кронекера](https://en.wikipedia.org/wiki/Kronecker_delta).

Частная производная количества вещества фазы $L$ по количеству вещества $l$-го компонента этой же фазы:

$$ \frac{\partial \ln n^L}{\partial n_l^L} = \frac{1}{n^L} \frac{\partial n^L}{\partial n_l^L} = \frac{1}{n^L} \frac{\partial}{\partial n_l^L} \sum_{i=1}^{N_c} n_i^L = \frac{1}{n^L} \sum_{i=1}^{N_c} \frac{\partial n_i^L}{\partial n_l^L} = \frac{1}{n^L}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c. $$

Частная производная количества вещества $l$-го компонента в $V$-й фазе по количеству вещества этого же компонента в фазе $L$:

$$ \frac{\partial n_l^V}{\partial n_l^L} = \frac{\partial}{\partial n_l^L} \left( n_l - n_l^L \right) = -1, \; l = 1 \, \ldots \, N_c. $$

С учетом изложенного выше элемент матрицы гессиана преобразуется к следующему виду:

$$ \begin{align}
H_{il}
&= \frac{\partial \ln \varphi_i^L}{\partial n_l^L} + \frac{\partial \ln \varphi_i^V}{\partial n_l^V} + \delta_{il} \left( \frac{1}{n_i^L} + \frac{1}{n_i^V} \right) - \left( \frac{1}{n^L} + \frac{1}{n^V} \right), \\
&= \frac{\partial \ln \varphi_i^L}{\partial n_l^L} + \frac{\partial \ln \varphi_i^V}{\partial n_l^V} + \delta_{il} \frac{n_i}{n_i^L n_i^V} - \frac{n}{n^L n^V} \\
&= \Phi_{il} + U_{il}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c,
\end{align} $$

где:

$$\begin{align}
\Phi_{il} &= \frac{\partial \ln \varphi_i^L}{\partial n_l^L} + \frac{\partial \ln \varphi_i^V}{\partial n_l^V}, \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c, \\
U_{il} &= \delta_{il} \frac{n_i}{n_i^L n_i^V} - \frac{n}{n^L n^V} = \frac{1}{n^L n^V} \left( \delta_{il} \frac{n_i}{y_i^L y_i^V} - n \right), \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c.
\end{align} $$

Если рассматривается система с $n = 1 \, моль$, тогда выражение для элемента матрицы $\mathbf{U}$:

$$ U_{il} = \frac{1}{F^L F^V} \left(  \frac{\delta_{il}}{u_i} - 1 \right), \; i = 1 \, \ldots \, N_c, \; l = 1 \, \ldots \, N_c, $$

где $u_i = y_i^L y_i^V \, / \, y_i$.

Причем матрица $\mathbf{U}$ в данном выражении – это та же матрица $\mathbf{U}$ в выражении для итерации метода градиентного спуска при минимизации энергии Гиббса относительно основных переменных, выраженных в виде логарифмов констант фазового равновесия. Частные производные логарифмов коэффициентов летучести компонентов могут быть получены с использованием средств [автоматического дифференцирования](https://en.wikipedia.org/wiki/Automatic_differentiation) при использовании, например, библиотеки [JAX](https://jax.readthedocs.io/en/latest/index.html), либо воспользовавшись аналитическими выражениями для нахождения производных, полученными [ранее](../2-EOS/EOS-Appendix-A-PD.md) для кубических уравнений состояния.

Таким образом, [система линейных уравнений](../../0-Math/0-LAB/LAB-10-LinearSystems) при рассмотрении проблемы поиска равновесеного состояния, как задачи минимизации энергии Гиббса, и при использовании метода Ньютона относительно количеств вещества компонентов в фазе $L$ записывается в следующем виде:

$$ \mathbf{H}_k \Delta \mathbf{n}^L_k = \mathbf{g}_k, $$

где $k$ – номер итерации. Эта система линейных уравнений разрешается относительно $\Delta \mathbf{n}^L_k$ и впоследствии используется в итерации метода Ньютона:

$$ \mathbf{n}^L_{k+1} = \mathbf{n}^L_{k} - \Delta \mathbf{n}^L_k, $$

Однако метод Ньютона также можно использовать, если выбрать логарифмы констант фазового равновесия в качестве основных переменных. В этом случае система линейных уравнений и итерация минимизации энергии Гиббса записываются следующим образом:

$$ \begin{align}
& \mathbf{J}_k \Delta \ln \mathbf{k}_k = \mathbf{g}_k, \\
& \ln \mathbf{k}_{k+1} = \ln \mathbf{k}_{k} - \Delta \ln \mathbf{k}_k,
\end{align} $$

где $\mathbf{J}_k = \mathbf{H}_k \mathbf{U}^{-1}_k.$

````{margin}
```{admonition} Дополнительно
Число обусловленности некоторой матрицы $\mathbf{A}$ является ее свойством и, грубо говоря, характеризует то, насколько сильно изменится решение системы линейных уравнений $\mathbf{A} \mathbf{x} = \mathbf{b}$ при некотором изменении вектора $\mathbf{b}$. При больших значениях числа обусловленности даже небольшие изменения вектора $\mathbf{b}$ могут вызвать существенные изменения вектора $\mathbf{x}$, поэтому если число обусловленности матрицы $\mathbf{A}$ невелико, то такая матрица называется *хорошо обусловленной (well-conditioned)*, и наоборот при большом числе обусловленности матрица называется *плохо обусловленной (ill-conditioned)*. Подробнее данное свойство матриц было рассмотрено [ранее](../../0-Math/0-LAB/LAB-11-ConditionNumber.md).
```
````

Очевидным преимуществом использования вектора количеств вещества компонентов в качестве основных переменных является отсутствие необходимости решения уравнения (или системы уравнений) Речфорда-Райса: в этом случае мольные доли компонентов в фазах и мольные доли фаз могут быть получены напрямую из вектора основных переменных. С другой стороны, преимуществом использования логарифмов констант фазового равновесия в качестве основных переменных является то обстоятельство, что матрица $\mathbf{J}$ характеризуется меньшим значением [числа обусловленности](https://en.wikipedia.org/wiki/Condition_number), по сравнению с матрицей $\mathbf{H}$, то есть матрица $\mathbf{J}$ является хорошо обусловленной \[[Petitfrere and Nichita, 2015](https://doi.org/10.1016/j.fluid.2014.11.017)\].

<!-- TODO: Показать изменение числа обусловленности матриц J и H в зависимости от давления. См.: 10.1016/j.fluid.2014.11.017. -->

````{margin}
```{admonition} Дополнительно
Однако не следует использовать метод решения системы линейных уравнений через нахождение обратной матрицы (по крайней мере, для матриц с размерностью 4 и более, для которых получение аналитических выражений для решения проблематично). Подробнее об этом можно прочитать [здесь](https://gregorygundersen.com/blog/2020/12/09/matrix-inversion/) и [здесь](../../0-Math/0-LAB/LAB-10-LinearSystems.md).
```
````

В обоих случаях на каждой итерации метода Ньютона требуется решение системы линейных уравнений для нахождения изменения основных переменных. Для этого могут применяться как [прямые](https://en.wikipedia.org/wiki/Matrix_decomposition), так и [итеративные методы решения](https://en.wikipedia.org/wiki/Iterative_method#Linear_systems). Обе группы методов решения системы линейных уравнений рассматривались [ранее](../../0-Math/0-LAB/LAB-10-LinearSystems.md). Для систем с небольшим количеством компонентов, которые чаще всего и встречаются в гидродинамическом моделировании, рекомендуется применение прямых методов, основанных на [разложении матриц](../../0-Math/0-LAB/LAB-9-Decomposition.md).

Гессиан энергии Гиббса, элемент которого для рассматриваемого случая определяется выражением

$$ H_{il} = \frac{\partial^2 G}{\partial n_i^L \partial n_l^l}, $$

````{margin}
```{admonition} Дополнительно
Если гессиан не является положительно определенной матрицей, то вектор изменения основных переменных может представлять собой не направление спуска, а направление к седловой точке или даже направление к максимуму. Подробнее – в разделе, посвященном [методам оптимизации функции](../../0-Math/1-OM/OM-0-Introduction.md).
```
````

представляет собой симметричную матрицу, которая в окресности решения является положительно определенной. Однако поскольку начальное приближение констант фазового равновесия может быть произвольным, то положительная определенность гессиана негарантирована. В качестве метода решения системы линейных уравнений в работе \[[Michelsen, 1982](https://doi.org/10.1016/0378-3812(82)85002-4)\] рекомендуется применение [модифицированного разложения Шолески](https://doi.org/10.1137/0911064), которое позволяет определить минимальное изменение $\mathbf{E}$ матрицы $\mathbf{H}$, гарантирующее положительную определенность матрицы $\mathbf{H} + \mathbf{E}$, и представить полученный результат в виде произведения двух нижнетреугольных матриц: $\mathbf{H} + \mathbf{E} = \mathbf{L}\mathbf{L}^\top$. При этом, если матрица $\mathbf{H}$ является положительно определенной, то $\mathbf{E} = 0$. Затем, зная нижнетреугольную матрицу, определяется вектор изменения основных переменных. Подробнее применение разложений для решения систем линейных уравнений рассматривалось [ранее](../../0-Math/0-LAB/LAB-10-LinearSystems.md).

В случае использования логарифмов констант фазового равновесия система линейных уравнений записывается относительно якобиана $\mathbf{J}$. Поскольку матрица $\mathbf{J}$ не является симметричной, то для разрешения системы линейных уравнений можно использовать [LU-разложение](https://en.wikipedia.org/wiki/LU_decomposition). Подробнее это также рассматривалось разделе, посвященном изучению [способов решения системы линейных уравнений](../../0-Math/0-LAB/LAB-10-LinearSystems.md). Однако, согласно \[[Petitfrere and Nichita, 2015](https://doi.org/10.1016/j.fluid.2014.11.017)\], время, необходимое на решение системы линейных уравнений будет в два раза меньше, по сравнению с LU-разложением, если сначала определить $\Delta \mathbf{n}_L$ с использованием представленного выше способа, а затем вычислить $\Delta \ln \mathbf{k}$, воспользовавшись соотношением:

$$ \Delta \ln \mathbf{k}_k = \mathbf{U}_k \Delta \mathbf{n}^L_k. $$

<!-- TODO: Показать изменение количества итераций с ростом давления для методов последовательных подстановок, Ньютона с гессианом H и Ньютона с якобианом J. См.: 10.1016/j.fluid.2014.11.017. Показать, почему метод последовательных подстановок плохо сходится вблизи линии насыщения или критической точки. -->

<!-- TODO: Показать пример, где метод Ньютона не сходится к решению из-за плохого начального приближения и неположительно определенной матрицы гессиана. Показать, как для этой задачи будет работать метод Ньютона с модифицированным разложением Шолески. -->

````{margin}
```{admonition} Дополнительно
Алгоритмы оптимизации могут быть классифицированы по порядку производной целевой функции, которую они используют в расчете изменения основных переменных. Так, например, метод градиентного спуска использует производные первого порядка целевой функции (градиент), поэтому его относят к методам первого порядка. Метод Ньютона использует производные второго порядка целевой функции (гессиан), поэтому он относится к методам второго порядка. Существуют также и алгоритмы нулевого порядка, при применении которых производные вообще не используются *(derivative-free methods)*. При этом, порядок алгоритма *(order of an algorithm)* в теории соотносится с порядком (скоростью) сходимости *(rate of convergence)*, однако, зачастую, это справедливо только вблизи решения (подробнее рассматривалось в [разделе про методы оптимизации функций](../../0-Math/1-OM/OM-0-Introduction.md)). Реальная же скорость сходимости зависит от начального приближения, вида оптимизируемой функции и др. На практике для оценки скорости сходимости используют [это](https://en.wikipedia.org/wiki/Rate_of_convergence#Order_estimation) выражение.
```
````

Другим решением проблемы негарантированной положительной определенности гессиана является поиск хорошего начального приближения. В связи с этим различными авторами рассматривается комбинированное использование метода последовательных подстановок (и его улучшенных альтернатив) и метода Ньютона. В этом случае метод последовательных подстановок используется на нескольких начальных итерациях с целью улучшения начального приближения, после чего происходит переключение на метод Ньютона. Естественно, проверять на каждой итерации является ли гессиан положительно определенной матрицей, является излишне ресурсозатратным. В связи с этим различными авторами были предложены косвенные условия, характеризующие о возможности перехода на использование методов второго порядка. Так, например, авторами работы \[[Mehra et al, 1982](https://doi.org/10.2118/9232-PA)\] были предложены следующие критерии для переключения:

$$ \begin{cases}
\sum_{j=1}^{N_p-1} \sum_{i=1}^{N_c} g_i^j \leq 10^{-4}, \\
\max_j \left| \frac{F^j_k - F^j_{k-1}}{F^j_{k-1}} \right| \leq 0.01 \lambda_k, \\
\sum_{j=1}^{N_p-1} L_j^2 \leq 10^{-8},
\end{cases} $$

где

$$ \begin{align}
& g_i^j = \ln K_i^{jR} + \ln \varphi_i^j - \ln \varphi_i^R, \; i = 1 \, \ldots \, N_c, \, j = 1 \, \ldots \, N_p-1, \\
& L_j = \sum_{i=1}^{N_c} \left( y_i^j - y_i^R \right), \; j = 1 \, \ldots \, N_p - 1.
\end{align} $$

Несколько иные условия переключения на методы второго порядка были предложены авторами работы \[[Nghiem et al, 1983](https://doi.org/10.2118/8285-PA)\]:

$$ \begin{cases}
\frac{\mathbf{g}_k^\top \mathbf{g}_k}{\mathbf{g}_{k-1}^\top {\mathbf{g}_{k-1}}} > \epsilon_R, \\
\left| F_k^V - F_{k-1}^V \right| < \epsilon_V, \\
\epsilon_L < \mathbf{g}_k^\top \mathbf{g}_k < \epsilon_U, \\
0 < F_k^V < 1.
\end{cases} $$

Первые два критерия свидетельствуют о медленной сходимости метода последовательных подстановок. Третий критерий показывает диапазон длины вектора невязок, при котором, по мнению авторов, наиболее рационально. Верхняя граница диапазона предотвращает преждевременное переключение на методы второго порядка. Несмотря на то что вблизи решения порядок сходимости метода Ньютона превышает порядок сходимости метода градиентного спуска, переключение с одного метода на другой не является целесообразным непосредственно вблизи решения. Наконец, последний критерий не допускает переключение на метод Ньютона, когда значения мольной доли одной из фаз равны нулю, принимая во внимание особенности задания начальных приближений, а также выражение для матрицы $\mathbf{U}$. Типовые значения параметров: $\epsilon_R = 0.6, \, \epsilon_V = 10^{-2}, \, \epsilon_L = 10^{-5}, \, \epsilon_U = 10^{-3}$.

<!-- TODO: Для этого же примера показать, как работает комбинированный метод с условиями переключения. -->

Третьим решением проблемы негарантированной положительной определенности матрицы гессиана является применение квази-ньютоновских методов, которые вместо гессиана $\mathbf{H}$ используют его аппроксимацию $\mathbf{B}$, являющуюся гарантированно положительно определенной (стоит отметить, что не все квази-ньютоновские методы могут это гарантировать). Одним из таких алгоритмов является [метод *BFGS*](https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm), рассмотренный [ранее](../../0-Math/1-OM/OM-0-Introduction.md). Применение метода *BFGS* для расчета фазового равновесия и анализа стабильности рассматривалось авторами работ \[[Ammar and Renon, 1987](https://doi.org/10.1002/aic.690330606); [Nichita and Petitfrere](https://doi.org/10.1016/j.fluid.2015.07.035)\]. Данный метод основан на следующей аппроксимации гессиана на $\left( k + 1 \right)$-й итерации:

$$ \mathbf{B}_{k+1} = \mathbf{B}_k + \frac{\mathbf{y}_k \mathbf{y}_k^\top}{\mathbf{y}_k^\top \mathbf{p}_k} - \frac{\mathbf{B}_k \mathbf{p}_k \left( \mathbf{B}_k \mathbf{p}_k \right)^\top }{\mathbf{p}_k^\top \mathbf{B}_k \mathbf{p}_k }, $$

где:

$$ \begin{align} \mathbf{y}_k &= \mathbf{g}_k - \mathbf{g}_{k-1}, \\ \mathbf{p}_k &= \mathbf{n}^L_k - \mathbf{n}^L_{k-1}. \end{align} $$

В этом случае изменение основных переменных, количеств вещества жидкой фазы, записывается следующим образом:

$$ \mathbf{n}^L_{k+1} = \mathbf{n}^L_{k} - \lambda \mathbf{B}_k^{-1} \mathbf{g}_k, $$

где $\lambda$ – длина шага итерации, определяемая в ходе процедуры *line search*. Для вычисления матрицы $\mathbf{B}_{k+1}^{-1}$ на $\left( k+1 \right)$-й итерации может быть использована [формула Шермана-Моррисона](https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula):

$$ \mathbf{B}_{k+1}^{-1} = \left( \mathbf{I} - \frac{\mathbf{p}_k \mathbf{y}_k^\top}{\mathbf{y}_k^\top \mathbf{p}_k} \right) \mathbf{B}_{k+1}^{-1} \left( \mathbf{I} - \frac{\mathbf{y}_k \mathbf{p}_k^\top}{\mathbf{y}_k^\top \mathbf{p}_k} \right) + \frac{\mathbf{p}_k \mathbf{p}_k^\top}{\mathbf{y}_k^\top \mathbf{p}_k}. $$

<!-- TODO: Как это выражение получилось? -->

Метод *BFGS* может быть использован и в случае выбора логарифмов констант фазового равновесия в качестве основных переменных. В этом случае на $\left( k+1 \right)$-й итерации:

$$ \ln \mathbf{k}_{k+1} = \ln \mathbf{k}_k - \lambda \mathbf{U} \mathbf{B}^{-1} \mathbf{g}. $$

При этом, на каждой итерации необходимо решать уравнение (систему уравнений) Речфорда-Райса для расчета мольных долей фаз и мольных долей компонентов в фазах.

<!-- TODO: Описать алгоритм BFGS для расчета равновесного состояния. -->

<!-- TODO: Показать, как для представленного выше примера работает метод BFGS. -->

Стоит отметить, что квази-ньютоновские методы имеют плохую сходимость для плохообусловленных проблем, хотя и не настолько плохую, как метод градиентного спуска \[[Alger, 2019](http://doi.org/10.26153/tsw/2663)\], модификацией которого является метод последовательных подстановок.

<!-- TODO: Показать, как изменяется количество итераций метода BFGS от давления. -->

Таким образом, в рамках данного подраздела были подробно рассмотрены различные алгоритмы расчета равновесного состояния для известных давления, температуры и компонентного состава, а также их реализации. Следующий подраздел будет посвящен нахождению равновесного состояния для известных объема, температуры и компонентного состава.

(pvt-esc-equilibrium-vt)=
## VT-термодинамика

<!-- TODO: Показать, как учитывать условие электронейтральности при расчете равновесного состояния. -->

<!-- TODO: Показать пример расчета равновесного состояния с учетом распределения ионов в полярных фазах. -->

Стоит отметить, что в данном разделе основное внимание уделялось алгоритмам нахождения равновесного состояния для различных условий. Однако оптимизация времени, затрачиваемого на работу того или иного алгоритма, зависит не только от самого алгоритма, но и от его реализации: работы с памятью, распараллеливания, векторизации вычислений. Подробнее это было рассмотрено авторами работы \[[Haugen and Beckner, 2013](https://doi.org/10.2118/163583-MS)\].

Данный раздел, был посвящен нахождению равновесного состояния для различных формулировок. В следующих разделах будут рассмотрены алгоритмы нахождения предельных состояний, характерных для многокомпонентных систем. В том числе речь пойдет про поиск линий насыщения, конденсации, а также про определение критического состояния системы, являющегося пределом фазового равновесия.
